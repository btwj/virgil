// Copyright 2024 Virgil Authors. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

def UNKNOWN_SIZE: int = -1;

component PackingUtil {
	def sizeOf(t: Type) -> int {
		match(t.typeCon.kind) {
			COMPONENT,
			VOID => return 0;
			INT => return IntType.!(t).width;
			BOOL => return 1;
			FLOAT => return FloatType.!(t).total_width;
			ENUM => return V3.getVariantTagType(t).width;
			ENUM_SET => return V3.getEnumSetType(t).width;
			_ => return UNKNOWN_SIZE;
		}
	}
}

class PackingVerifier(prog: Program, ERROR: ErrorGen, file: VstFile) {
	def sizes = Strings.newMap<int>(); // -1 if unknown size
	def fieldsByStart = HashMap<byte, Vector<string>>.new(int.!<byte>, byte.==);
	def fields = Strings.newMap<()>();

	def addVar(name: string, size: int) {
		sizes[name] = size;

		if (!fieldsByStart.has(name[0])) fieldsByStart[name[0]] = Vectors.of1(name);
		else fieldsByStart[name[0]].put(name);
	}

	def error(range: FileRange, error: string, msg: string) {
		ERROR.addError(range, file.extractLine(range.beginLine), error, msg);
	}
	def PackingSizeError(range: FileRange, actual: int, expected: int) {
		PackingError(range, Strings.format2("expected bit size of %d but got %d", expected, actual));
	}
	def PackingError(range: FileRange, msg: string) {
		error(range, "PackingError", msg);
	}
	def size(l: Literal) -> int {
		if (FloatLiteral.?(l)) {
			PackingError(l.range(), "packing size cannot be a float");
			return UNKNOWN_SIZE;
		}
		var val = l.val;
		return V3.unboxI32(val);
	}
	def verifyHasFields(names: List<Token>) {
		for (n = names; n != null; n = n.tail) {
			var name = n.head;
			if (!fields.has(name.image)) {
				PackingError(name.range(), Strings.format1("packing missing field %s", name.image));
			}
		}
	}
	private def getTokenFromParam(x: (Token, Literal)) -> Token { return x.0; }
	def verifyDecl(p: VstPacking) {
		for (p = p.params.list; p != null; p = p.tail) {
			var param = p.head;
			addVar(param.0.image, size(param.1));
		}
		var declSize = size(p.size);
		checkExprHasSize(p.expr, declSize);
		verifyHasFields(Lists.map(p.params.list, getTokenFromParam));
	}
	def verifyExpr(d: VstClass, p: VstPackingExpr) {
		for (param = d.params.list; param != null; param = param.tail) {
			var p = param.head;
			addVar(p.name(), PackingUtil.sizeOf(p.tref.binding));
		}
		match (p) {
			Tuple(l) => {
				// Top level tuple: each element is a scalar
				for (p = l.list; p != null; p = p.tail) checkExpr(p.head);
			}
			_ => checkExpr(p);
		}
		verifyHasFields(Lists.map(d.params.list, ParamDecl.token));
	}
	def checkExprHasSize(p: VstPackingExpr, s: int) {
		var size = checkExpr(p);
		if (s != UNKNOWN_SIZE && size != UNKNOWN_SIZE && s != size) {
			PackingSizeError(p.range(), s, size);
		}
	}
	def checkBits(b: VstBits) -> int {
		// ensure fields are unambiguous
		// TODO: handle wildcards
		var lengths = Array<int>.new(256);
		for (i < b.bits.length) {
			match (b.bits[i]) {
				Char(c) => lengths[c]++;
				_ => ;
			}
		}
		for (i < 256) {
			var c = byte.!(i);
			if (lengths[c] == 0) continue;
			match (fieldsByStart[c].length) {
				0 => PackingError(b.r, Strings.format1("'%c' does not refer to any field", c));
				1 => {
					var fieldName = fieldsByStart[c][0];
					if (sizes[fieldName] != UNKNOWN_SIZE && sizes[fieldName] != lengths[c]) {
						PackingError(b.r, Strings.format3("expected %d bits for field %s, but got %d bits", sizes[fieldName], fieldName, lengths[c]));
					}
					fields[fieldName] = ();
				}
				_ => PackingError(b.r, Strings.format1("'%c' is ambiguous", c));
			}	
		}
		return b.bits.length;
	}
	def checkExpr(p: VstPackingExpr) -> int {
		match (p) {
			Bits(b) => return checkBits(b);
			Tuple(l) => {
				var total = 0;
				for (p = l.list; p != null; p = p.tail) {
					var s = checkExpr(p.head);
					total = if(s == UNKNOWN_SIZE, UNKNOWN_SIZE, total + s);
				}
				return total;
			}
			App(p, args) => {
				var name = p.ident.name.image;
				var appDecl = prog.packings[name];

				if (appDecl == null) {
					PackingError(p.range(), Strings.format1("packing %s not found", name));
					return UNKNOWN_SIZE;
				}

				var numParams = appDecl.params.length();
				var numArgs = args.length();

				if (appDecl.params.length() != args.length()) {
					PackingError(p.range(), Strings.format3("packing %s expects %d arguments, got %d", name, numParams, numArgs));
					return UNKNOWN_SIZE;
				}

				var curArg = args.list;
				for (p = appDecl.params.list; p != null; p = p.tail) {
					checkExprHasSize(curArg.head, size(p.head.1));
					curArg = curArg.tail;
				}
				return size(appDecl.size);
			}
			Field(f) => {
				var name = f.ident.name.image;
				fields[name] = ();
				return if(sizes.has(name), sizes[name], UNKNOWN_SIZE);
			}
			Literal(l) => ;
		}
		return UNKNOWN_SIZE;
	}
}