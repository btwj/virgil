// Copyright 2024 Virgil Authors. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

def UNKNOWN_SIZE: i32 = -1;

class PackingVerifier(prog: Program, ERROR: ErrorGen, file: VstFile) {
	def sizes = Strings.newMap<i32>(); // -1 if unknown size
	def fieldsByStart = Array<(string, bool)>.new(256);

	def addVar(name: string, size: i32) {
		sizes[name] = size;

		if (!fieldsByStart[name[0]].1) fieldsByStart[name[0]] = (name, true);
		else fieldsByStart[name[0]] = (null, true);
	}

	def error(range: FileRange, error: string, msg: string) {
		ERROR.addError(range, file.extractLine(range.beginLine), error, msg);
	}
	def PackingSizeError(range: FileRange, actual: i32, expected: i32) {
		PackingError(range, Strings.format2("expected bit size of %d but got %d", expected, actual));
	}
	def PackingError(range: FileRange, msg: string) {
		error(range, "PackingError", msg);
	}
	def size(l: Literal) -> i32 {
		if (FloatLiteral.?(l)) {
			PackingError(l.range(), "packing size cannot be a float");
		}
		var val = l.val;
		return V3.unboxI32(val);
	}
	def verifyDecl(p: VstPacking) {
		for (p = p.params.list; p != null; p = p.tail) {
			var param = p.head;
			addVar(param.0.image, size(param.1));
		}
		var declSize = size(p.size);
		checkExprHasSize(p.expr, declSize);
	}
	def verifyExpr(p: VstPackingExpr) {
		match (p) {
			Tuple(l) => {
				// Top level tuple: each element is a scalar
				for (p = l.list; p != null; p = p.tail) checkExpr(p.head);
			}
			_ => checkExpr(p);
		}
	}

	def checkExprHasSize(p: VstPackingExpr, s: i32) {
		var size = checkExpr(p);

		if (s != UNKNOWN_SIZE && size != UNKNOWN_SIZE && s != size) {
			PackingSizeError(p.range(), s, size);
		}
	}
	def checkBits(b: VstBits) -> i32 {
		// ensure fields are unambiguous
		// TODO: handle wildcards

		var length = Array<int>.new(256);
		for (i < b.bits.length) {
			match (b.bits[i]) {
				Char(c) => length[c]++;
				_ => ;
			}
		}

		for (c < 256) {
			if (length[c] == 0) continue;
			if (fieldsByStart[c].0 == null) {
				PackingError(b.r, Strings.format1("'%c' is ambiguous", c));
				continue;
			}

			var fieldName = fieldsByStart[c].0;
			if (sizes[fieldName] != UNKNOWN_SIZE && sizes[fieldName] != length[c]) {
				PackingError(b.r, Strings.format3("expected %d bits for field %s, but got %d bits", sizes[fieldName], fieldName, length[c]));
			}
		}
		return b.bits.length;
	}
	def checkExpr(p: VstPackingExpr) -> i32 {
		match (p) {
			Bits(b) => return checkBits(b);
			Tuple(l) => {
				var total = 0;
				for (p = l.list; p != null; p = p.tail) {
					var s = checkExpr(p.head);
					total = if(s == UNKNOWN_SIZE, UNKNOWN_SIZE, total + s);
				}
				return total;
			}
			App(p, args) => {
				var name = p.ident.name.image;
				var appDecl = prog.packings[name];

				if (appDecl == null) {
					PackingError(p.range(), Strings.format1("packing %s not found", name));
					return UNKNOWN_SIZE;
				}

				var numParams = appDecl.params.length();
				var numArgs = args.length();

				if (appDecl.params.length() != args.length()) {
					PackingError(p.range(), Strings.format3("packing %s expects %d arguments, got %d", name, numParams, numArgs));
					return UNKNOWN_SIZE;
				}

				var curArg = args.list;
				for (p = appDecl.params.list; p != null; p = p.tail) {
					checkExprHasSize(curArg.head, size(p.head.1));
					curArg = curArg.tail;
				}
				return size(appDecl.size);
			}
			Field(f) => {
				var name = f.ident.name.image;
				return if(sizes.has(name), sizes[name], UNKNOWN_SIZE);
			}
			Literal(l) => ;
		}
		return UNKNOWN_SIZE;
	}
}