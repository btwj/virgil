// Copyright 2024 Virgil Authors. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

def UNKNOWN_FIELD_SIZE: i32 = -1;

class PackingVerifier(prog: Program, ERROR: ErrorGen, file: VstFile) {
	def sizes = Strings.newMap<i32>(); // -1 if unknown size
	def addVar(name: string, size: i32) { sizes[name] = size; }

	def error(range: FileRange, error: string, msg: string) {
		ERROR.addError(range, file.extractLine(range.beginLine), error, msg);
	}
	def SizeError(range: FileRange, actual: i32, expected: i32) {
		error(range, "SizeError", Strings.format2("expected bit size of %d but got %d", expected, actual));
	}
	def size(l: Literal) -> i32 {
		if (FloatLiteral.?(l)) {
			error(l.range(), "SizeError", "packing size cannot be a float");
		}
		var val = l.val;

		return UNKNOWN_FIELD_SIZE;
	}
	def verifyDecl(p: VstPacking) {
		for (p = p.params.list; p != null; p = p.tail) {
			var param = p.head;
			addVar(param.0.image, size(param.1));
		}
		checkExpr(p.expr);
	}
	def verifyExpr(p: VstPackingExpr) { checkExpr(p); }

	def checkExprHasSize(p: VstPackingExpr, s: i32) {
		var size = checkExpr(p);
		if (s != UNKNOWN_FIELD_SIZE && size != UNKNOWN_FIELD_SIZE && s != size) {
			SizeError(p.range(), s, size);
		}
	}
	def checkExpr(p: VstPackingExpr) -> i32 {
		match (p) {
			Bits(b) => return b.length;
			Tuple(l) => Lists.apply(l.list, checkExpr);
			App(p, args) => {
				var appDecl = prog.packings[p.name];
			}
			Field(f) => ;
			Literal(l) => ;
		}
		return UNKNOWN_FIELD_SIZE;
	}
}