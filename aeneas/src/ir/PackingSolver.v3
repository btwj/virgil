// Copyright 2024 Virgil authors. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

/*
Scalars can either be 'ref' or 'nonref' scalars, and are handled by the GC in
different ways. The GC knows whether a specific slot is a ref or nonref scalar
by using compile-time information (the stackmap).

For ref scalars, the runtime can specify different 'classes' that it is able to
recognize and distinguish, and whether those representations will be scanned by
the GC. For instance, on x86-64, the classes available are:
- 0b_????_????_????_????_...._...._...._...._...._...._...._...._...._...._...._.??0 [scanned]
- 0b_????_????_????_????_????_????_????_????_????_????_????_????_????_????_????_???1 [ignored]

Based on each class, the packing solver is able to squeeze other fields into the
unassigned portions of the representation.
*/

type Bit {
	case Unassigned; // ?
	case Fixed(v: u1); // 0 or 1
	case Unusable; // .
}

 // TODO: Allow non-contiguous intervals to be represented
type Interval(s: int, e: int) {
	def render(sb: StringBuilder) -> StringBuilder {
		return sb.put2("%d-%d", s, e);
	}
}

component PackingPatterns {
	def fromString(s: string) -> PackingPattern {
		var bits = Vector<Bit>.new();
		for (i < s.length) {
			var c = s[s.length - i - 1];
			match (c) {
				_ => ;
				'0' => bits.put(Bit.Fixed(0));
				'1' => bits.put(Bit.Fixed(1));
				'.' => bits.put(Bit.Unusable);
				'?' => bits.put(Bit.Unassigned);
			}
		}
		return PackingPattern.new(bits.extract());
	}
}

class PackingPattern(bits: Array<Bit>) {
	def size = bits.length;
	
	def render(s: StringBuilder) -> StringBuilder {
		for (i < bits.length) {
			var b = bits[bits.length - i - 1];
			if (i != 0 && i % 8 == 0) s.putc('_');
			match (b) {
				Unassigned => s.putc('?');
				Fixed(v) => s.put1("%d", v);
				Unusable => {
					// s.puts(Terminal.CTRL_GREEN);
					// s.pututf8(0x25ae);
					// s.puts(Terminal.CTRL_DEFAULT);
					s.putc('.');
				}
			}
		}
		return s;
	}
	def getIntervalsForSize(s: int) -> Array<Interval> {
		var i = 0;
		var intervals = Vector<Interval>.new();

		for (i < size - s + 1) {
			var start = size - s - i;
			var isEmpty = true;
			for (j < s) {
				if (bits[start + j] != Bit.Unassigned) {
					isEmpty = false;
					break;
				}
			}
			if (isEmpty) intervals.put(Interval(start, start + s));
		}
		return intervals.extract();
	}
	def assignInterval(i: Interval) {
		for (j = i.s; j < i.e; j++) bits[j] = Bit.Unusable;
	}
	def tryAssignInterval(i: Interval) -> bool {
		for (j = i.s; j < i.e; j++) if (bits[j] != Bit.Unassigned) return false;
		assignInterval(i);
		return true;
	}
	def unassignInterval(i: Interval) {
		for (j = i.s; j < i.e; j++) bits[j] = Bit.Unassigned;
	}
	def copy() -> PackingPattern { return PackingPattern.new(Arrays.dup(bits)); }
}

type PackingField {
	case Nonref(size: byte);
	case Ref;
}

type CaseField(caseIdx: int, fieldIdx: int) {
	def hash() -> int { return caseIdx * 31 + fieldIdx; }
}

class PackingSolver(size: byte, refPatterns: RefPatterns) {
	var cases: Array<Array<PackingField>>;
	var fieldOrder: Array<CaseField>;
	var assignments = HashMap<CaseField, Interval>.new(CaseField.hash, CaseField.==);

	def reset() {
		cases = null;
		fieldOrder = null;
		assignments = HashMap<CaseField, Interval>.new(CaseField.hash, CaseField.==);
	}

	def canDistinguish(state: Array<PackingPattern>, elements: Array<bool>) -> bool {
		// TODO: split on bits with the most unassigned
		var numElements = 0;
		for (i in elements) if (i) numElements++;
		if (numElements <= 1) return true;

		for (i < size) {
			// try to split on this bit
			var numZeros = 0, numOnes = 0, numUnassigned = 0;
			for (j < state.length) {
				if (!elements[j]) continue;
				match (state[j].bits[i]) {
					Fixed(v) => if (v == 0) numZeros++; else numOnes++;
					Unassigned => numUnassigned++;
					Unusable => ;
				}
			}

			if (numUnassigned == 0 && (numZeros == 0 || numOnes == 0)) continue; // useless
			if (numUnassigned == 1 && numZeros == 0 && numOnes == 0) continue;

			var zeros = Array<bool>.new(elements.length);
			var ones = Array<bool>.new(elements.length);
			var parity: u1 = 0;
			var temporaryBits = Vector<int>.new();

			for (j < state.length) {
				if (!elements[j]) continue;
				match (state[j].bits[i]) {
					Unusable => zeros[j] = ones[j] = true;
					Fixed(v) => {
						if (v == 0) zeros[j] = true;
						else ones[j] = true;
					}
					Unassigned => {
						temporaryBits.put(j);
						// XXX: do more than alternate the unassigned bits in this column
						state[j].bits[i] = Bit.Fixed(parity);
						if (parity == 0) zeros[j] = true;
						else ones[j] = true;
						parity++;
					}
				}
			}

			if (canDistinguish(state, zeros) && canDistinguish(state, ones)) return true;
			for (j < temporaryBits.length) state[temporaryBits[j]].bits[i] = Bit.Unassigned;
		}
		return false;
	}

	def checkDistinguishable(state: Array<PackingPattern>) -> bool {
		// if there are enough aligned ?s, we can just use them to tag

		var unassigned = Vector<int>.new();
		for (i < size) {
			var allUnassigned = true;
			for (j < state.length) {
				if (state[j].bits[i] != Bit.Unassigned) {
					allUnassigned = false;
					break;
				}
			}
			if (allUnassigned) unassigned.put(i);
		}

		var result = false;
		if (1 << byte.!(unassigned.length) >= state.length) {
			result = true;
			for (j < state.length) {
				for (k < unassigned.length) {
					var bit = u1.!((j >> byte.!(k)) & 1);
					state[j].bits[unassigned[k]] = Bit.Fixed(bit);
					if (1 << byte.!(k) >= state.length) break;
				}
			}
		} else {
			// difficult case: we have to build the decision tree and check
			var elements = Array<bool>.new(state.length);
			for (i < elements.length) elements[i] = true;
			result = canDistinguish(state, elements);
		}
		return result;
	}

	// Backtracking solver
	def solve(idx: int, state: Array<PackingPattern>) -> HashMap<CaseField, Interval> {
		// for (i < state.length) Terminal.put3("%d %d: %q\n", idx, i, state[i].render);
		if (idx == fieldOrder.length) return if(checkDistinguishable(state), assignments, null);

		var CaseField = fieldOrder[idx];
		var caseIdx = CaseField.caseIdx, fieldIdx = CaseField.fieldIdx;
		var field = cases[caseIdx][fieldIdx];
		var possibleIntervals = state[caseIdx].getIntervalsForSize(PackingField.Nonref.!(field).size);
		if (possibleIntervals.length == 0) return null;

		for (interval in possibleIntervals) {
			state[caseIdx].assignInterval(interval);
			assignments[CaseField] = interval;
			var result = solve(idx + 1, state);
			if (result != null) return result;
			state[caseIdx].unassignInterval(interval);
		}
		return null;
	}

	// Find a packing for a single scalar
	def solveScalar(problem: PackingProblem) -> PackingSolution {
		cases = problem.cases;
		var isRefScalar = false;
		for (i < cases.length) {
			var caseHasRef = false;
			for (field in cases[i]) {
				match (field) {
					Ref => {
						if (caseHasRef) return null; // cannot pack more than one ref into a single scalar per case
						isRefScalar = caseHasRef = true;
					}
					_ => ;
				}
			}
		}

		var patterns = Array<PackingPattern>.new(cases.length);
		if (isRefScalar) {
			for (i < cases.length) {
				var c = cases[i];
				var casePacking: PackingPattern;

				var containsRef = false;
				for (j < cases[i].length) {
					var f = cases[i][j], fl = CaseField(i, j);
					match (f) {
						Ref => {
							assignments[fl] = refPatterns.refInterval;
							casePacking = refPatterns.ptrref.copy();
							casePacking.assignInterval(refPatterns.refInterval);
							containsRef = true;
						}
						_ => ;
					}
				}

				if (!containsRef) casePacking = refPatterns.nonptrref.copy();
				patterns[i] = casePacking;
			}
		} else {
			// can use all bits
			for (i < cases.length) patterns[i] = refPatterns.nonref.copy();
		}

		for (assignment in problem.assignments) {
			var cf = assignment.0, interval = assignment.1;
			patterns[cf.caseIdx].assignInterval(interval);
			assignments[cf] = interval;
		}

		var fieldsToSolve = Vector<CaseField>.new();
		for (i < cases.length) {
			for (j < cases[i].length) {
				var cf = CaseField(i, j);
				if (!assignments.has(cf)) fieldsToSolve.put(cf);
			}
		}
		fieldOrder = fieldsToSolve.extract();
		this.cases = cases;
		
		var solution = solve(0, patterns);
		if (solution == null) return null;

		return PackingSolution.new(patterns, assignments, isRefScalar, problem);
	}
}

type PackingProblem(cases: Array<Array<PackingField>>, assignments: Array<(CaseField, Interval)>) #unboxed {
	def render(sb: StringBuilder) -> StringBuilder {
		var h = HashMap<CaseField, Interval>.new(CaseField.hash, CaseField.==);
		for (a in assignments) h[a.0] = a.1;

		for (i < cases.length) {
			if (i > 0) sb.csp();
			sb.put1("#%d=[", i);
			for (j < cases[i].length) {
				if (j > 0) sb.csp();
				match (cases[i][j]) {
					Nonref(s) => sb.put1("%d", s);
					Ref => sb.puts("ref");
				}
				var cf = CaseField(i, j);
				if (h.has(cf)) sb.put1("@%q", h[cf].render);
			}
			sb.puts("]");
		}
		return sb;
	}
}

class PackingSolution(patterns: Array<PackingPattern>, assignments: HashMap<CaseField, Interval>, isRef: bool, problem: PackingProblem) {}

type RefPatterns(
	ptrref: PackingPattern,
	refInterval: Interval,
	nonptrref: PackingPattern,
	nonref: PackingPattern
);

component MachPatterns {
	def X86_64 = RefPatterns(
		PackingPatterns.fromString("????_????_????_????_...._...._...._...._...._...._...._...._...._...._...._.??0"),
		Interval(3, 48),
		PackingPatterns.fromString("????_????_????_????_????_????_????_????_????_????_????_????_????_????_????_???1"),
		PackingPattern.new(Array<Bit>.new(64))
	);
	def X86 = RefPatterns(
		PackingPatterns.fromString("...._...._...._...._...._...._...._.??0"),
		Interval(3, 32),
		PackingPatterns.fromString("????_????_????_????_????_????_????_???1"),
		PackingPattern.new(Array<Bit>.new(32))
	);
}