// Norm for variants (both superclass and case class)
class VariantNorm extends TypeNorm {
	new (oldType: Type, newType: Type, sub: Array<Type>)
		super(oldType, newType, sub) {
	}
}

class VariantParentNorm extends VariantNorm {
	new (oldType: Type, newType: Type, sub: Array<Type>)
		super(oldType, newType, sub) {
	}
}
// Norm of a variant with unboxed cases
class UnboxedVariantParentNorm extends VariantParentNorm {
	def tagType: IntType;
	var boxedIndex = -1;

	new (oldType: Type, newType: Type, tagType, sub: Array<Type>)
		super(oldType, newType, sub) {
	}
}

// Norm of the variant case
class VariantCaseNorm extends VariantNorm {
	var parentNorm: VariantParentNorm;

	new (oldType: Type, newType: Type, sub: Array<Type>)
		super(oldType, newType, sub) {
	}
}
class UnboxedVariantCaseNorm extends VariantCaseNorm {
	def fieldIndexesInParent: Array<Array<int>>; // indices in parent norm
	def fieldIndexes: Array<Array<int>>;
	def origRanges: Array<(int, int)>;
	def exactTypes: Array<Type>;

	new (oldType: Type, newType: Type, sub: Array<Type>, exactTypes, fieldIndexesInParent, fieldIndexes, origRanges)
		super(oldType, newType, sub) {
	}

	def render(buf: StringBuilder) -> StringBuilder {
		buf.put3("%q ## %q |%d|", oldType.render, newType.render, size);
		if (sub == null) return buf;
		buf.puts(" [");
		for (i < sub.length) {
			if (i > 0) buf.csp();
			sub[i].render(buf);
		}
		buf.puts("] (");
		for (i < fieldIndexesInParent.length) {
			if (i > 0) buf.csp();
			buf.putc('(');
			for (j < fieldIndexesInParent[i].length) {
				if (j > 0) buf.csp();
				buf.put1("%d", fieldIndexesInParent[i][j]);
			}
			buf.putc(')');
		}
		buf.puts(") (");
		for (i < fieldIndexes.length) {
			if (i > 0) buf.csp();
			buf.putc('(');
			for (j < fieldIndexes[i].length) {
				if (j > 0) buf.csp();
				buf.put1("%d", fieldIndexes[i][j]);
			}
			buf.putc(')');
		}
		buf.putc(')');
		return buf;
	}
}
class BoxedVariantCaseNorm extends VariantCaseNorm {
	var boxedIndex = -1;
	new (oldType: Type, newType: Type, sub: Array<Type>)
		super(oldType, newType, sub) {
	}
}
// For variants with only a single unboxed case,
// or empty variants that are represented as enums
class DataVariantCaseNorm extends VariantCaseNorm {
	def tagType: IntType;
	def origRanges: Array<(int, int)>;
	def normRanges: Array<(int, int)>;

	new(oldType: Type, newType: Type, tagType, origRanges, normRanges, sub: Array<Type>)
		super(oldType, newType, sub) {
	}
}

// Relevant facts:
// RC_ENUM
// RC_UNBOXED
// RC_BOXED

class VariantSolver(nc: NormalizerConfig, rn: ReachabilityNormalizer, verbose: bool) {
	// lay out a variant's fields, which may be flattened
	def normVariant(t: Type, rc: RaClass) -> TypeNorm {
		if (rc.variantNorm != null) return rc.variantNorm; // already unboxed
		if (rc.orig.boxing == Boxing.BOXED) rn.mapSimple(t); // XXX, ugly, don't recurse through explicitly boxed types

		var prev = rc.recursive;
		match (rc.recursive) {
			ON_STACK => {
				rc.recursive = 2; // cycle detected; box
			}
			0 => {
				rc.recursive = ON_STACK;
				tryUnboxing(rc);
				if (rc.recursive == ON_STACK) rc.recursive = 1;
				if (rc.variantNorm != null) return rc.variantNorm;
			}
			// recursive or not; there was no data norm, so box
		}
		rc.raFacts |= RaFact.RC_BOXED;
		return rn.mapSimple(t);
	}
	def tryUnboxing(rc: RaClass) -> bool {
		if (rc.normFields != null) return rc.variantNorm != null; // already done

		while (rc.parent != null) rc = rc.parent;
		rn.makeNormFields(rc);
		var isEmpty = rc.normFields.length == 0, closure = rc.raFacts.RC_CLOSURE;
		var hasUnboxedCases = false;
		for (l = rc.children; l != null; l = l.tail) {
			var c = l.head;
			rn.makeNormFields(c);
			if (c.normFields.length > 0) isEmpty = false;
			if (c.orig.boxing == Boxing.UNBOXED) hasUnboxedCases = true;
			closure |= c.raFacts.RC_CLOSURE;
		}
		if (isEmpty && !closure) {
			// normalize empty variant to just its tag; i.e. become an enum
			var tagType = V3.getVariantTagType(rc.oldType);
			setDataNormForChildren(rc, tagType, [tagType], RaFact.RC_ENUM | RaFact.RC_UNBOXED);
			return true;
		}
		if (rc.children != null) {
			if (CLOptions.UNBOX_VARIANTS.get() == VstMatcher.None) {
				return false;
			}
			match (rc.orig.boxing) {
				BOXED => return false;
				AUTO => if (!hasUnboxedCases) return false;
				_ => ;
			}
			return unboxUsingUnboxedNorm(rc);
		}
		match (rc.orig.boxing) {
			BOXED => return false; // program specified boxed
			AUTO => if (rc.normFields.length > nc.MaxFlatDataValues) return false; // auto unbox up to compiler limit
			UNBOXED => ; // program specified unboxed; TODO: recursion or closure should be an error
		}
		if (rc.recursive > 1 || closure) return false; // recursive or closed over
		unboxUsingDataNorm(rc);
		return true;
	}
	def unboxUsingDataNorm(rc: RaClass) {
		// Flatten a data type
		var of = rc.orig.fields;
		var origRanges = Array<(int, int)>.new(of.length);
		var normRanges = Array<(int, int)>.new(of.length);
		var vecO = Vector<Type>.new();
		var vecT = Vector<Type>.new();
		// map fields of original IrClass to ranges in the original and normalized type
		for (i < of.length) {
			var origStart = vecO.length, normStart = vecT.length;
			if (i <= rc.fields.length) {
				var rf = rc.fields[i];
				if (rf != null) {
					rf.raFacts |= RaFact.RC_UNBOXED;
					if (rf.normIndex >= 0) {
						if (rf.typeNorm != null) {
							rf.typeNorm.addTo(vecT);
						} else if (rf.fieldType != null) {
							rf.typeNorm = rn.norm(rf.fieldType);
							rf.typeNorm.addTo(vecT);
						} else {
							vecT.put(rf.orig.fieldType);
						}
					}
				}
			}
			var fieldType = of[i].fieldType.substitute(V3.getTypeArgs(rc.oldType));
			rn.norm(fieldType).addTo(vecO);
			origRanges[i] = (origStart, vecO.length);
			normRanges[i] = (normStart, vecT.length);
		}
		var ta = vecT.extract();
		rc.variantNorm = DataVariantCaseNorm.new(rc.oldType, Tuple.newType(Lists.fromArray(ta)), null, origRanges, normRanges, ta);
		rc.raFacts |= RaFact.RC_UNBOXED;
	}
	def unboxUsingUnboxedNorm(rc: RaClass) -> bool {
		var vecT = Vector<Type>.new();
		var fieldIndexesInParent = Vector<Array<int>>.new();
		var fieldIndexes = Vector<Array<int>>.new();

		var tagType = V3.getVariantTagType(rc.oldType);
		var allUnboxed = rc.orig.boxing == Boxing.UNBOXED;

		var boxedIndex = -1;

		for (l = rc.children; l != null; l = l.tail) {
			var c = l.head;
			if (!allUnboxed && c.orig.boxing != Boxing.UNBOXED) {
				// Box this case
				c.raFacts |= RaFact.RC_BOXED;

				if (boxedIndex < 0) {
					boxedIndex = vecT.length;
					vecT.put(rc.oldType);
				}
				var bvcn = BoxedVariantCaseNorm.new(c.oldType, c.oldType, [c.oldType]);
				bvcn.boxedIndex = boxedIndex;
				c.variantNorm = bvcn;
				if (verbose) Terminal.put1("      boxed %q\n", l.head.oldType.render);
				continue;
			}

			if (verbose) Terminal.put1("    unboxed %q\n", l.head.oldType.render);

			var of = c.orig.fields;
			var vecO = Vector<Type>.new();
			var origRanges = Array<(int, int)>.new(of.length);

			var classFields = Vector<Type>.new();
			var indexesUsed = Vector<int>.new();

			for (i < of.length) {
				var rf = c.fields[i];
				rf.raFacts |= RaFact.RC_UNBOXED;

				var nf = Vector<Type>.new();
				var curMapping = Vector<int>.new();
				var indexes = Vector<int>.new();

				if (rf.typeNorm != null) {
					rf.typeNorm.addTo(nf);
				} else if (rf.fieldType != null) {
					var tn = rn.norm(rf.fieldType);
					tn.addTo(nf);
				} else {
					nf = Vectors.of1(rf.orig.fieldType);
				}

				for (j < nf.length) {
					var assigned = -1;

					// Try to find an existing field to use
					for (k < vecT.length) {
						var alreadyUsed = false;
						// XXX: Inefficient
						for (t < indexesUsed.length) if (indexesUsed[t] == k) alreadyUsed = true;

						var possibleSupertype = nc.TypesCompatible(nf[j], vecT[k]);
						if (!alreadyUsed && possibleSupertype != null) {
							// TODO: Heuristic - don't always use the supertype
							vecT[k] = possibleSupertype;
							assigned = k;
							break;
						}
					}

					indexes.put(classFields.length);
					if (assigned >= 0) {
						curMapping.put(assigned);
						indexesUsed.put(assigned);
					} else {
						var m = vecT.length;
						vecT.put(nf[j]);
						curMapping.put(m);
						indexesUsed.put(m);
					}
					classFields.put(nf[j]);
				}
				var origStart = vecO.length;

				var fieldType = of[i].fieldType.substitute(V3.getTypeArgs(rc.oldType));
				rn.norm(fieldType).addTo(vecO);

				origRanges[i] = (origStart, vecO.length);
				fieldIndexesInParent.put(curMapping.extract());
				fieldIndexes.put(indexes.extract());
			}

			classFields.put(tagType);

			// XXX: Delay to end so no rewriting necessary
			c.variantNorm = UnboxedVariantCaseNorm.new(
				c.oldType, Tuple.newType(Lists.fromArray(classFields.copy())), classFields.copy(), classFields.copy(), fieldIndexesInParent.extract(), fieldIndexes.extract(), origRanges);
			c.raFacts |= RaFact.RC_UNBOXED;
		}

		vecT.put(tagType);
		var vecTArray = vecT.extract();
		var parentNorm = UnboxedVariantParentNorm.new(rc.oldType, Tuple.newType(Lists.fromArray(vecTArray)), tagType, vecTArray);
		for (l = rc.children; l != null; l = l.tail) {
			var vcn = VariantCaseNorm.!(l.head.variantNorm);
			vcn.parentNorm = parentNorm;
			
			// We need to recompute the sub array because some of the parent fields were overridden by supertypes
			match (vcn) {
				null => ;
				uvcn: UnboxedVariantCaseNorm => {
					for (i < uvcn.fieldIndexesInParent.length) {
						for (j < uvcn.fieldIndexesInParent[i].length) {
							uvcn.sub[uvcn.fieldIndexes[i][j]] = vecTArray[uvcn.fieldIndexesInParent[i][j]];
						}
					}
				}
			}
			if (verbose) Terminal.put1("    norm %q\n", vcn.render);
		}
		rc.variantNorm = parentNorm;
		rc.raFacts |= RaFact.RC_UNBOXED;

		if (verbose) Terminal.put1("    norm %q\n", rc.variantNorm.render);

		return true;
	}
	def setDataNormForChildren(rc: RaClass, tagType: IntType, sub: Array<Type>, facts: RaFact.set) {
		rc.variantNorm = DataVariantCaseNorm.new(rc.oldType, tagType, tagType, NO_RANGES, NO_RANGES, sub);
		rc.raFacts |= facts;
		for (l = rc.children; l != null; l = l.tail) {
			setDataNormForChildren(l.head, tagType, sub, facts);
		}
	}
}
def ON_STACK = -1;
def NO_RANGES = Array<(int, int)>.new(0);