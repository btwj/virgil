// Copyright 2024 Virgil authors. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

enum Scalar(size: byte, ty: Type) {
	B32(32, Int.getType(true, 32)),
	B64(64, Int.getType(true, 64)),
	F32(32, Float.FLOAT32),
	F64(64, Float.FLOAT64),
	R32(32, AnyRef.TYPE),
	R64(64, AnyRef.TYPE),
	Ref(64, AnyRef.TYPE),
}
def getScalarFromSet(s: Scalar.set) -> Scalar {
	for (i in s) return i;
	return Scalar.B32; // should be unreachable
}
def getTypeFromScalarSet(s: Scalar.set, usePacking: bool) -> Type {
	for (i in s) return if(usePacking, IntRep.getType(i), i.ty);
	return null;
}

class VariantPattern(scalars: Array<ScalarPattern>) {
	def render(buf: StringBuilder) -> StringBuilder {
		for (i < scalars.length) {
			if (i > 0) buf.putc('|');
			buf.put1("%q", scalars[i].render);
		}
		return buf;
	}
}

class VariantNorm extends TypeNorm {
	def fields: Array<VariantField>;
	var vecO: Array<Type>;

	def tag: VariantField;
	var tagValue: int = -1;

	// for each field, this is the start + end index when ClassAlloc is called
	var fieldRanges: Array<(int, int)>;
	var children: List<VariantNorm>;

	new(oldType: Type, newType: Type, sub: Array<Type>, fields, tag)
		super(oldType, newType, sub) {}

	// represent empty variant as tag
	def isEnum() -> bool { return size == 1 && tag != null && fields.length == 0; }
	def isEnumCase() -> bool { return size == 1 && tag != null && tagValue >= 0 && fields.length == 0; }

	def tagType() -> IntType { return IntType.!(tag.tn.first()); }
	def tagIndex() -> int { return tag.indexes[0]; }
	
	// represent single-case, unboxed variant without its tag
	def hasNoTag() -> bool { return tag == null; }
	// tagging is explicit - may be packed, or a separate scalar
	def hasExplicitTag() -> bool { return tag != null; }
	// tagging is implicit (i.e. decision tree required)
	def hasImplicitTag() -> bool { return false; }

	def render(buf: StringBuilder) -> StringBuilder {
		buf.put3("%q ## %q |%d|", oldType.render, newType.render, size);
		buf.puts(" [");
		for (i < sub.length) {
			if (i > 0) buf.csp();
			sub[i].render(buf);
		}
		buf.puts("] {");
		if (tag != null) buf.put1("ftag: %q", tag.render);
		for (i < fields.length) {
			if (i > 0 || tag != null) buf.csp();
			buf.put2("f%d=%q", i, fields[i].render);
		}
		buf.puts("}");
		return buf;
	}
}

// Metadata about a variant's fields before/after normalization
class VariantField {
	def tn: TypeNorm;
	def indexes: Array<int>; // Indexes into the variant's representation to extract the field from
	var intervals: Array<Interval>; // null, if no packing

	new(tn, indexes) {}

	def isPacked() -> bool { return intervals != null; }
	def render(buf: StringBuilder) -> StringBuilder {
		buf.puts("(");
		for (i < indexes.length) {
			if (i > 0) buf.csp();
			buf.put1("#%d", indexes[i]);
			if (intervals != null) buf.put1("@%q", intervals[i].render);
		}
		if (tn != null) buf.put1(": %q", tn.newType.render);
		buf.puts(")");
		return buf;
	}
}

def ON_STACK = -1;
def EMPTY_FIELD = VariantField.new(null, []);
def NO_FIELDS = Array<VariantField>.new(0);

class VariantSolver(vnorm: VariantNormalizer, usePacking: bool, useTagScalar: bool) {
	var normFields: Array<Array<Type>>;

	var fields: Vector<CaseField>; // an ordering of fields to solve for during packing

	// final solutions
	var scalarAsns: HashMap<CaseField, int>; // field location -> scalar idx
	var intervalAsns: HashMap<CaseField, Interval>; // field location -> interval within scalar
	var state: Array<VariantPattern>;

	var explicitTagLength: byte;
	var explicitTag: (int, Interval) = (-1, Interval(0, 0));

	var curRep: Vector<Scalar.set>;
	var curUsed: Vector<byte>;
	
	// Perform recursive backtracking on the potential representation.
	// With each scalar in each case, we have several choices to make:
	// 1. Pack this scalar with an existing scalar
	// 2. Append this scalar as a new scalar.
	// We can only determine distinguishability after all the scalars have been assigned. Heuristics will help speed this part up.
	private def tryRepresentationForField(curCase: int, curField: int) -> bool {
		if (curCase >= normFields.length) {
			// XXX: check distinguishable
			return solvePacking();
		}
		if (curField >= normFields[curCase].length) {
			// move on to next case
			curUsed = Vector<byte>.new();
			for (i < curRep.length) curUsed.put(0);
			return tryRepresentationForField(curCase + 1, 0);
		}
		
		var sc = vnorm.nc.GetScalar(vnorm.rn.ra.compiler, vnorm.rn.ra.prog, normFields[curCase][curField]);
		var bw = vnorm.nc.GetBitWidth(vnorm.rn.ra.compiler, vnorm.rn.ra.prog, normFields[curCase][curField]);
		if (!usePacking) bw = 64; // then no fields can be merged!
		
		var none: Scalar.set;

		for (i < curRep.length) {
			if (curUsed[i] >= 64) continue;
			var oldRep = curRep[i];

			if ((sc & oldRep) != none) {
				curUsed[i] += bw; curRep[i] = sc & oldRep;
				scalarAsns[CaseField(curCase, curField)] = i;
				if (tryRepresentationForField(curCase, curField + 1)) return true;
				curUsed[i] -= bw; curRep[i] = oldRep;
			}
		}

		var len = curRep.length;
		curRep.put(sc); curUsed.put(bw);
		scalarAsns[CaseField(curCase, curField)] = curRep.length - 1;
		if (tryRepresentationForField(curCase, curField + 1)) return true;
		curRep.resize(len); curUsed.resize(len);

		return false;
	}
	private def tryExplicitTaggingHeuristic() -> bool {
		for (i < state[0].scalars.length) {
			var scalar0 = state[0].scalars[i];
			var longest: Interval, curStart: byte = 0;
			for (j < scalar0.bits.length) {
				var allUnassigned = true;
				for (k < state.length) {
					if (state[k].scalars[i].bits[j] != PackingBit.Unassigned) {
						allUnassigned = false;
						break;
					}
				}

				if (allUnassigned) {
					if (j + 1 - curStart > longest.size()) longest = Interval(curStart, byte.!(j + 1));
				} else {
					curStart = byte.!(j + 1);
				}
			}

			if (explicitTagLength > 0 && longest.size() >= explicitTagLength) {
				for (j < state.length) {
					for (k < explicitTagLength) {
						var bit = u1.!((j >> k) & 1);
						state[j].scalars[i].bits[longest.start + k] = PackingBit.Fixed(bit);
					}
				}
				explicitTag = (i, Interval(longest.start, longest.start + explicitTagLength));
				return true;
			}
		}
		return false;
	}
	private def canDistinguish(active: Array<bool>) {
		// TODO - this is where unassigned bits will get assigned
	}
	private def checkDistinguishable() -> bool {
		var result = tryExplicitTaggingHeuristic();
		// TODO: try difficult tagging
		return result;
	}
	private def solveField(idx: int) -> bool {
		if (idx >= fields.length) {
			if (useTagScalar) return true;
			return checkDistinguishable();
		}
		var field = fields[idx];
		var scalarAsn = scalarAsns[field];

		// try to squeeze this field into this scalar
		var casePattern = state[field.caseIdx];
		var bw = vnorm.nc.GetBitWidth(vnorm.rn.ra.compiler, vnorm.rn.ra.prog, normFields[field.caseIdx][field.fieldIdx]);
		var scalar = casePattern.scalars[scalarAsn];
		var intervals = scalar.getIntervalsForSize(bw);

		if (intervals.length == 0) return false;
		for (interval in intervals) {
			scalar.assignInterval(interval);
			intervalAsns[field] = interval;
			var result = solveField(idx + 1);
			if (result) return true;
			scalar.unassignInterval(interval);
		}
		return false;
	}
	private def getScalarPattern(s: Scalar) -> ScalarPattern {
		// XXX: Should be based on scalar type
		return ScalarPattern.new(Array<PackingBit>.new(s.size));
	}
	private def solvePacking() -> bool {
		var cases = Array<VariantPattern>.new(normFields.length);
		// build up patterns from the individual cases
		for (i < normFields.length) {
			var patterns = Array<ScalarPattern>.new(curRep.length);
			for (j < curRep.length) patterns[j] = getScalarPattern(getScalarFromSet(curRep[j]));
			cases[i] = VariantPattern.new(patterns);
		}
		state = cases;

		var result = solveField(0);
		if (result) Terminal.put1("%q\n", render);
		return result;
	}
	def render(buf: StringBuilder) -> StringBuilder {
		for (i < normFields.length) {
			if (i > 0) buf.csp();
			buf.put1("c%d: [", i);
			for (j < normFields[i].length) {
				if (j > 0) buf.csp();
				var cf = CaseField(i, j);
				var field = normFields[i][j];
				buf.put2("f%d=%q: ", j, field.render);

				if (!scalarAsns.has(cf)) buf.puts("?");
				else if (!intervalAsns.has(cf)) buf.put1("#%d@?", scalarAsns[cf]);
				else buf.put2("#%d@%q", scalarAsns[cf], intervalAsns[cf].render);
			}
			buf.puts("]");
		}
		buf.ln();
		for (i < state.length) {
			buf.put1("%q\n", state[i].render);
		}
		return buf;
	}
	def reset() {
		scalarAsns = HashMap<CaseField, int>.new(CaseField.hash, CaseField.==);
		intervalAsns = HashMap<CaseField, Interval>.new(CaseField.hash, CaseField.==);
		curRep = Vector<Scalar.set>.new();
		curUsed = Vector<byte>.new();
		fields = Vector<CaseField>.new();
	}
	private def getTagLength(numCases: int) -> byte {
		var i: byte = 0;
		while (1 << i < numCases) i++;
		return i;
	}
	def solve(cases: Array<Array<Type>>) -> bool {
		reset();
		normFields = cases;
		explicitTagLength = getTagLength(cases.length);

		// TODO: Express solving constraints here (from annotations)
		for (i < normFields.length) {
			for (j < normFields[i].length) fields.put(CaseField(i, j));
		}
		return tryRepresentationForField(0, 0);
	}
}

class VariantNormalizer(nc: NormalizerConfig, rn: ReachabilityNormalizer, verbose: bool) {
	def usePacking = CLOptions.PACKING.get();
	// Normalizes a non-recursive variant, returns either a VariantNorm for an unboxed variant,
	// or a simple TypeNorm for a boxed variant
	def normVariant(t: Type, rc: RaClass) -> TypeNorm {
		if (rc.variantNorm != null) return rc.variantNorm;
		if (rc.orig.boxing == Boxing.BOXED) rn.mapSimple(t);

		var prev = rc.recursive;
		match (rc.recursive) {
			ON_STACK => {
				rc.recursive = 2; // cycle detected; box
			}
			0 => {
				rc.recursive = ON_STACK;
				tryUnboxing(rc);
				if (rc.recursive == ON_STACK) rc.recursive = 1;
				if (rc.variantNorm != null) return rc.variantNorm;
			}
		}
		return rn.mapSimple(t); 
	}
	// Try to unbox a variant in one of three ways:
	// 1. If a (non-closure) variant has all empty fields in all cases, represent it as a single uN tag (enum representation).
	// 2. If a variant has only one case, represent it as a tagless tuple of scalars (data representation).
	// 3. If a variant has multiple cases and is marked #unboxed, use a flattened representation with the smallest set of scalars.
	private def tryUnboxing(rc: RaClass) -> bool {
		if (rc.variantNorm != null) return true; // already done
		while (rc.parent != null) rc = rc.parent;
		
		rn.makeNormFields(rc);

		var isEmpty = rc.normFields.length == 0;
		var closure = rc.raFacts.RC_CLOSURE;

		for (l = rc.children; l != null; l = l.tail) {
			var c = l.head;
			rn.makeNormFields(c);
			if (c.normFields.length > 0) isEmpty = false;
			closure |= c.raFacts.RC_CLOSURE;
		}

		if (isEmpty && !closure) {
			// normalize empty variant to just its tag; i.e. become an enum
			var tagType = V3.getVariantTagType(rc.oldType);
			var tagTypeNorm = rn.norm(tagType);
			var tagField = VariantField.new(tagTypeNorm, [0]);
			unboxUsingEnumVariantNorm(rc, tagType, tagField);
			return true;
		}
		if (rc.children != null) {
			// multi-case variant unboxing
			if (closure) return false;
			match (rc.orig.boxing) {
				BOXED, AUTO => return false;
				_ => return unboxUsingTaggedVariantNorm(rc);
			}
		}
		match (rc.orig.boxing) {
			BOXED => return false;
			AUTO => if (rc.normFields.length > nc.MaxFlatDataValues) return false;
			UNBOXED => ; // program specified unboxed; TODO: recursion or closure should be an error
		}
		if (rc.recursive > 1 || closure) return false; // recursive or closed over
		unboxUsingTaglessVariantNorm(rc);
		return true;
	}
	private def unboxUsingTaglessVariantNorm(rc: RaClass) {
		var ofs = rc.orig.fields;
		var fields = Array<VariantField>.new(ofs.length);
		var fieldRanges = Array<(int, int)>.new(ofs.length);

		var vecO = Vector<Type>.new();
		var vecT = Vector<Type>.new();

		for (i < ofs.length) {
			var normStart = vecT.length, origStart = vecO.length;
			var rf = rc.fields[i];
			var indexes: Array<int>;

			if (rf != null && rf.normIndex >= 0) {
				var tn = fieldNorm(rf);
				tn.addTo(vecT);

				indexes = Array<int>.new(tn.size);
				for (j < indexes.length) indexes[j] = normStart + j;
				fields[i] = VariantField.new(tn, indexes);
			} else fields[i] = EMPTY_FIELD;
			
			var fieldType = ofs[i].fieldType.substitute(V3.getTypeArgs(rc.oldType));
			rn.norm(fieldType).addTo(vecO);
			fieldRanges[i] = (origStart, vecO.length);
		}

		var ta = vecT.extract();
		var vn = VariantNorm.new(rc.oldType, Tuple.newType(Lists.fromArray(ta)), ta, fields, null);
		vn.fieldRanges = fieldRanges;
		vn.vecO = vecO.extract();
		rc.variantNorm = vn;

		// TODO: packing

		if (verbose) Terminal.put1("variant norm %q\n", rc.variantNorm.render);
	}
	// Perform recursive backtracking on the potential representation.
	// With each scalar in each case, we have several choices to make:
	// 1. Merge this scalar with an existing scalar in the representation that hasn't been used by the current case.
	// 2. Append this scalar as a new scalar.
	// We can only determine distinguishability after all the scalars have been assigned. Heuristics will help speed this part up.
	var assignments: HashMap<CaseField, int>;
	private def tryRepresentationForField(curRep: Vector<Scalar.set>, curUsed: Vector<bool>, fields: Array<Array<Type>>, curCase: int, curField: int) -> bool {	
		if (curCase >= fields.length) {
			// XXX: check distinguishable
			return true; // true, since we add a tag scalar - this will change once packing is involved
		}
		if (curField >= fields[curCase].length) {
			// move on to next case
			curUsed = Vector<bool>.new();
			for (i < curRep.length) curUsed.put(false);
			return tryRepresentationForField(curRep, curUsed, fields, curCase + 1, 0);
		}
		
		var sc = nc.GetScalar(rn.ra.compiler, rn.ra.prog, fields[curCase][curField]);
		var none: Scalar.set;

		for (i < curRep.length) {
			if (curUsed[i]) continue;
			var oldRep = curRep[i];

			if ((sc & oldRep) != none) {
				curUsed[i] = true; curRep[i] = sc & oldRep;
				assignments[CaseField(curCase, curField)] = i;
				if (tryRepresentationForField(curRep, curUsed, fields, curCase, curField + 1)) return true;
				curUsed[i] = false; curRep[i] = oldRep;
			}
		}

		var len = curRep.length;
		curRep.put(sc); curUsed.put(true);
		assignments[CaseField(curCase, curField)] = curRep.length - 1;
		if (tryRepresentationForField(curRep, curUsed, fields, curCase, curField + 1)) return true;
		curRep.resize(len); curUsed.resize(len);

		return false;
	}
	private def unboxUsingTaggedVariantNorm(rc: RaClass) -> bool {
		var vecT = Vector<Type>.new();
		var parentUnboxed = rc.orig.boxing == Boxing.UNBOXED;

		var numChildren = Lists.length(rc.children);
		var normFields = Array<Array<Type>>.new(numChildren);

		var caseIdx = 0;
		for (l = rc.children; l != null; l = l.tail) {
			var c = l.head;
			var ofs = c.orig.fields;

			var fields = Array<VariantField>.new(ofs.length);
			var fieldTypes = Vector<Type>.new();

			c.fieldRangesO = Array<(int, int)>.new(ofs.length);
			c.fieldRangesT = Array<(int, int)>.new(ofs.length);
			var vecO = Vector<Type>.new();

			for (i < ofs.length) {
				var rf = c.fields[i];
				var startT = fieldTypes.length;

				if (rf != null && rf.normIndex >= 0) {
					var tn = fieldNorm(rf);
					tn.addTo(fieldTypes);
					fields[i] = VariantField.new(tn, Array<int>.new(tn.size));
				} else fields[i] = EMPTY_FIELD;

				var origStart = vecO.length;
				var fieldType = ofs[i].fieldType.substitute(V3.getTypeArgs(rc.oldType));
				rn.norm(fieldType).addTo(vecO);
				c.fieldRangesO[i] = (origStart, vecO.length);
				c.fieldRangesT[i] = (startT, fieldTypes.length);
			}

			c.variantFields = fields;
			c.vecO = vecO.extract();
			normFields[caseIdx++] = fieldTypes.extract();
		}

		if (rc.recursive > 1) return false;
		// now that we know it's not recursive, we can safely assign the variant norm

		var solver = VariantSolver.new(this, usePacking, false);
		var result = solver.solve(normFields);
		var needsTagScalar = false;
		if (!result) {
			// try again, but allow an explicit tag scalar
			solver = VariantSolver.new(this, usePacking, true);
			result = solver.solve(normFields);
			needsTagScalar = true;
			if (!result) return false; // XXX: warn that no solution was found
		}

		var tagType = V3.getVariantTagType(rc.oldType);
		var types: Array<Type>;

		if (needsTagScalar) {
			types = Array<Type>.new(solver.curRep.length + 1);
			for (i < solver.curRep.length) types[i] = getTypeFromScalarSet(solver.curRep[i], usePacking);
			types[solver.curRep.length] = tagType;
		} else {
			types = Array<Type>.new(solver.curRep.length);
			for (i < solver.curRep.length) types[i] = getTypeFromScalarSet(solver.curRep[i], usePacking);
		}

		var tagField: VariantField;
		if (needsTagScalar) tagField = VariantField.new(rn.norm(tagType), [solver.curRep.length]);
		else if (solver.explicitTag.0 >= 0) {
			tagField = VariantField.new(rn.norm(tagType), [solver.explicitTag.0]);
			tagField.intervals = [solver.explicitTag.1];
		}
		var newType = Tuple.newType(Lists.fromArray(types));

		var parentNorm = VariantNorm.new(rc.oldType, newType, types, NO_FIELDS, tagField);
		Terminal.put1("%q\n", parentNorm.render);

		var childrenNorms: List<VariantNorm>;
		rc.variantNorm = parentNorm;

		var children = rc.children;
		for (i < numChildren) {
			var child = children.head;
			var ofs = child.orig.fields;

			for (j < ofs.length) {
				var rf = child.fields[j];
				if (rf != null && rf.normIndex >= 0) {
					var fr = child.fieldRangesT[j];
					if (usePacking) child.variantFields[j].intervals = Array<Interval>.new(fr.1 - fr.0);
					for (k < fr.1 - fr.0) {
						child.variantFields[j].indexes[k] = solver.scalarAsns[CaseField(i, fr.0 + k)];
						if (usePacking) child.variantFields[j].intervals[k] = solver.intervalAsns[CaseField(i, fr.0 + k)];
					}
				}
			}

			var vn = VariantNorm.new(child.oldType, newType, types, child.variantFields, tagField);
			vn.fieldRanges = child.fieldRangesT;
			vn.vecO = child.vecO;
			vn.tagValue = V3.getVariantTag(child.oldType);
			
			child.variantNorm = vn;
			children = children.tail;
			childrenNorms = List<VariantNorm>.new(vn, childrenNorms);

			Terminal.put1("  %q\n", vn.render);
		}
		parentNorm.children = childrenNorms;
		
		return true;
	}
	private def unboxUsingEnumVariantNorm(rc: RaClass, tagType: IntType, tagField: VariantField) {
		var vn = VariantNorm.new(rc.oldType, tagType, [tagType], NO_FIELDS, tagField);
		vn.tagValue = V3.getVariantTag(rc.oldType);
		rc.raFacts |= RaFact.RC_ENUM;
		rc.variantNorm = vn;
		
		for (l = rc.children; l != null; l = l.tail) unboxUsingEnumVariantNorm(l.head, tagType, tagField);
	}
	private def fieldNorm(rf: RaField) -> TypeNorm {
		if (rf.typeNorm != null) return rf.typeNorm;
		else if (rf.fieldType != null) return rf.typeNorm = rn.norm(rf.fieldType);
		else return rn.norm(rf.orig.fieldType);
	}
}
