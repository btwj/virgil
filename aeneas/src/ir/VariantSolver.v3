// Norm for variants (both superclass and case class)
class VariantNorm extends TypeNorm {
	def tagType: IntType;
	def isCase: bool;

	new (oldType: Type, newType: Type, tagType: IntType, isCase: bool, sub: Array<Type>)
		super(oldType, newType, sub) {
	}
}
// Norm of a variant with unboxed cases
class UnboxedVariantNorm extends VariantNorm {
	// case-specific fields, null for parent
	def caseTypes: Array<Type>;
	def parentNorm: VariantNorm;
	def fieldIndexes: Array<Array<int>>;

	new (oldType: Type, newType: Type, tagType: IntType,
		parentNorm, caseTypes, fieldIndexes, sub: Array<Type>)
		super(oldType, newType, tagType, parentNorm != null, sub) {
	}
}

// For variants with only a single unboxed case, or empty variants that are represented as enums
class DataVariantNorm extends VariantNorm {
	def origRanges: Array<(int, int)>;
	def normRanges: Array<(int, int)>;

	new(oldType: Type, newType: Type, tagType: IntType, origRanges, normRanges, sub: Array<Type>)
		super(oldType, newType, tagType, true, sub) {
	}
}

private type VariantCase(fieldTypes: Array<Array<Type>>, fieldIndexes: Array<Array<int>>) #unboxed;

class VariantSolver(nc: NormalizerConfig, rn: ReachabilityNormalizer, verbose: bool) {
	// lay out a variant's fields, which may be flattened
	def normVariant(t: Type, rc: RaClass) -> TypeNorm {
		if (rc.variantNorm != null) return rc.variantNorm; // already unboxed
		if (rc.orig.boxing == Boxing.BOXED) rn.mapSimple(t); // XXX, ugly, don't recurse through explicitly boxed types

		var prev = rc.recursive;
		match (rc.recursive) {
			ON_STACK => {
				rc.recursive = 2; // cycle detected; box
			}
			0 => {
				rc.recursive = ON_STACK;
				tryUnboxing(rc);
				if (rc.recursive == ON_STACK) rc.recursive = 1;
				if (rc.variantNorm != null) return rc.variantNorm;
			}
			// recursive or not; there was no data norm, so box
		}
		rc.raFacts |= RaFact.RC_BOXED;
		return rn.mapSimple(t);
	}
	def tryUnboxing(rc: RaClass) -> bool {
		if (rc.normFields != null) return rc.variantNorm != null; // already done

		while (rc.parent != null) rc = rc.parent;
		rn.makeNormFields(rc);
		var isEmpty = rc.normFields.length == 0, closure = rc.raFacts.RC_CLOSURE;
		var hasUnboxedCases = false;
		for (l = rc.children; l != null; l = l.tail) {
			var c = l.head;
			rn.makeNormFields(c);
			if (c.normFields.length > 0) isEmpty = false;
			if (c.orig.boxing == Boxing.UNBOXED) hasUnboxedCases = true;
			closure |= c.raFacts.RC_CLOSURE;
		}
		if (isEmpty && !closure) {
			// normalize empty variant to just its tag; i.e. become an enum
			var tagType = V3.getVariantTagType(rc.oldType);
			setDataNormForChildren(rc, tagType, [tagType], RaFact.RC_ENUM | RaFact.RC_UNBOXED);
			return true;
		}
		if (rc.children != null) {
			if (CLOptions.UNBOX_VARIANTS.get() == VstMatcher.None) {
				return false;
			}
			match (rc.orig.boxing) {
				BOXED => return false;
				AUTO => if (!hasUnboxedCases) return false;
				_ => ;
			}
			return unboxUsingUnboxedNorm(rc);
		}
		match (rc.orig.boxing) {
			BOXED => return false; // program specified boxed
			AUTO => if (rc.normFields.length > nc.MaxFlatDataValues) return false; // auto unbox up to compiler limit
			UNBOXED => ; // program specified unboxed; TODO: recursion or closure should be an error
		}
		if (rc.recursive > 1 || closure) return false; // recursive or closed over
		unboxUsingDataNorm(rc);
		return true;
	}
	def unboxUsingDataNorm(rc: RaClass) {
		// Flatten a data type
		var of = rc.orig.fields;
		var origRanges = Array<(int, int)>.new(of.length);
		var normRanges = Array<(int, int)>.new(of.length);
		var vecO = Vector<Type>.new();
		var vecT = Vector<Type>.new();
		// map fields of original IrClass to ranges in the original and normalized type
		for (i < of.length) {
			var origStart = vecO.length, normStart = vecT.length;
			if (i <= rc.fields.length) {
				var rf = rc.fields[i];
				if (rf != null) {
					rf.raFacts |= RaFact.RC_UNBOXED;
					if (rf.normIndex >= 0) {
						if (rf.typeNorm != null) {
							rf.typeNorm.addTo(vecT);
						} else if (rf.fieldType != null) {
							rf.typeNorm = rn.norm(rf.fieldType);
							rf.typeNorm.addTo(vecT);
						} else {
							vecT.put(rf.orig.fieldType);
						}
					}
				}
			}
			var fieldType = of[i].fieldType.substitute(V3.getTypeArgs(rc.oldType));
			rn.norm(fieldType).addTo(vecO);
			origRanges[i] = (origStart, vecO.length);
			normRanges[i] = (normStart, vecT.length);
		}
		var ta = vecT.extract();
		rc.variantNorm = DataVariantNorm.new(rc.oldType, Tuple.newType(Lists.fromArray(ta)), null, origRanges, normRanges, ta);
		rc.raFacts |= RaFact.RC_UNBOXED;
	}
	private def synthesizeClassType (decl: VstClass) -> ClassType {
		decl.typeCon = V3Class_TypeCon.new(decl, rn.ra.prog.typeCache);
		var classType = decl.getDeclaredType();
		return ClassType.!(classType);
	}
	def unboxUsingUnboxedNorm(rc: RaClass) -> bool {
		var vecT = Vector<Type>.new();
		var cases = Vector<VariantCase>.new();

		var tagType = V3.getVariantTagType(rc.oldType);
		var parentUnboxed = rc.orig.boxing == Boxing.UNBOXED;

		// superclass for all boxed cases in this partially-unboxed variant
		var boxedScName = StringBuilder.new().put1("%q$box", rc.oldType.render).toString();
		var boxedScDecl = VstClass.new(false, Token.new("<generated>", boxedScName, 0, 0), null, null, null, null, null);
		var boxedScType = synthesizeClassType(boxedScDecl);
		var boxedScIc = rn.newIr.makeIrClass(boxedScType);
		var boxedScRc = RaClass.new(boxedScType, boxedScIc, null);
		rn.ra.classes.put(boxedScRc);

		for (l = rc.children; l != null; l = l.tail) {
			var c = l.head;
			var caseUnboxed = parentUnboxed || c.orig.boxing == Boxing.UNBOXED;

			if (!caseUnboxed) {
				c.raFacts |= RaFact.RC_BOXED; // boxed case of an unboxed variant
				var boxedIndex = -1;

				var boxedClassName = StringBuilder.new().put1("%q$box", c.oldType.render).toString();
				var boxedClassDecl = VstClass.new(false, Token.new("<generated>", boxedClassName, 0, 0), null, ClassType.!(c.oldType).classDecl.params,
					TypeUtil.typeRefOf(boxedScType), null, null);
				var boxedType = synthesizeClassType(boxedClassDecl);

				var builder = IrBuilder.new(boxedType, boxedScIc);

				var paramDecls = ClassType.!(c.oldType).classDecl.params;
				var context = SsaContext.new(rn.ra.compiler, rn.ra.prog);
				var numParams = if(paramDecls != null, paramDecls.length(), 0);
				var paramTypes = Array<Type>.new(numParams + 1);
				var params = Array<SsaParam>.new(numParams + 1);

				params[0] = SsaParam.new(0, boxedType);
				paramTypes[0] = boxedType;
				
				if (paramDecls != null) {
					for (l = paramDecls.list; l != null; l = l.tail) {
						var p = l.head;
						Terminal.put2("id=%d fieldType=%q\n", p.index, p.vtype.render);
						paramTypes[p.index] = p.vtype;
						params[p.index] = SsaParam.new(p.index, p.vtype);
						builder.addIrField(IrField.new(boxedType, p.vtype));
					}
				}
				
				var constructor = IrMethod.new(boxedType, null, Function.siga(paramTypes, boxedType));
				constructor.setFact(Fact.M_NEW);
				builder.addIrMethod(constructor);
				context.enterMethod(constructor);

				constructor.ssa = SsaGraph.new(params, boxedType);
				context.graph = constructor.ssa;
				var block = SsaBuilder.new(context, constructor.ssa, constructor.ssa.startBlock);
				for (i = 1; i < params.length; i++) {
					var spec = IrSpec.new(boxedType, [boxedType], builder.fields[i-1]);
					block.addApply(null, V3Op.newClassInitField(spec), [params[0], params[i]]);
				}
				block.addReturn([params[0]]);
				context.printSsa("Generated");

				var boxedIc = builder.build();
				var boxedRc = RaClass.new(boxedType, boxedIc, boxedScRc);
				boxedRc.newIrType = boxedType;
				rn.ra.typeMap[boxedType] = boxedRc;
				rn.ra.classes.put(boxedRc);

				var mc = rn.ra.makeMethod([boxedType], constructor, null);
				mc.raFacts |= RaFact.RM_LIVE;
				rn.ra.liveMethods.put(mc);

				for (i < boxedIc.fields.length) {
					var rf = boxedRc.makeField(boxedIc.fields[i], boxedIc.fields[i].fieldType);
					boxedIc.fields[i].raField = rf;
					rf.raFacts |= RaFact.RF_INIT | RaFact.RF_READ; // ensure fields survive during normalization
				}

				for (i < vecT.length) {
					var supertype = nc.TypesCompatible(vecT[i], boxedType);
					if (supertype != null) {
						boxedIndex = i;
						break;
					}
				}

				if (boxedIndex < 0) {
					boxedIndex = vecT.length;
					vecT.put(boxedType);
				}

				cases.put(VariantCase([[boxedType]], [[boxedIndex]]));
				continue;
			}

			c.raFacts |= RaFact.RC_UNBOXED;
			var of = c.orig.fields;
			var fieldTypes = Array<Array<Type>>.new(of.length);
			var fieldIndexes = Array<Array<int>>.new(of.length);
			var indexesUsed = HashMap<int, void>.new(int.!<int>, int.==);

			for (i < of.length) {
				var rf = c.fields[i];
				rf.raFacts |= RaFact.RC_UNBOXED;

				var nf = Vector<Type>.new();
				if (rf.typeNorm != null) {
					rf.typeNorm.addTo(nf);
				} else if (rf.fieldType != null) {
					rn.norm(rf.fieldType).addTo(nf);
				} else {
					nf = Vectors.of1(rf.orig.fieldType);
				}
				fieldTypes[i] = nf.extract();
				fieldIndexes[i] = Array<int>.new(fieldTypes[i].length);

				for (j < fieldTypes[i].length) {
					var assigned = -1;

					// Try to find an existing field to use
					for (k < vecT.length) {
						if (indexesUsed.has(k)) continue;

						var supertype = nc.TypesCompatible(fieldTypes[i][j], vecT[k]);
						if (supertype != null) {
							// TODO: Heuristic - don't always use the supertype
							vecT[k] = supertype;
							assigned = k;
							break;
						}
					}

					if (assigned < 0) {
						assigned = vecT.length;
						vecT.put(fieldTypes[i][j]);
					}
					indexesUsed[assigned] = ();
					fieldIndexes[i][j] = assigned;
				}
			}

			cases.put(VariantCase(fieldTypes, fieldIndexes));
		}

		vecT.put(tagType); // TODO: assume tag is at the back for now
		var parentNorm = UnboxedVariantNorm.new(rc.oldType, Tuple.newType(Lists.fromArray(vecT.copy())), tagType, null, null, null, vecT.copy());
		rc.variantNorm = parentNorm; rc.raFacts |= RaFact.RC_UNBOXED;
		if (verbose) Terminal.put1("variant norm %q\n", rc.variantNorm.render);

		var caseIndex = 0;
		for (l = rc.children; l != null; l = l.tail) {
			var c = l.head;
			var vc = cases[caseIndex]; caseIndex++;
			var caseTypes = vecT.copy();

			for (i < vc.fieldIndexes.length) {
				for (j < vc.fieldIndexes[i].length) {
					caseTypes[vc.fieldIndexes[i][j]] = vc.fieldTypes[i][j];
				}
			}

			var caseNorm = UnboxedVariantNorm.new(c.oldType, Tuple.newType(Lists.fromArray(caseTypes)), tagType, parentNorm, caseTypes, vc.fieldIndexes, caseTypes);
			c.variantNorm = caseNorm;
			if (verbose) Terminal.put1("-- case norm %q\n", caseNorm.render);
		}
		
		return true;
	}
	def setDataNormForChildren(rc: RaClass, tagType: IntType, sub: Array<Type>, facts: RaFact.set) {
		rc.variantNorm = DataVariantNorm.new(rc.oldType, tagType, tagType, NO_RANGES, NO_RANGES, sub);
		rc.raFacts |= facts;
		for (l = rc.children; l != null; l = l.tail) {
			setDataNormForChildren(l.head, tagType, sub, facts);
		}
	}
}
def ON_STACK = -1;
def NO_RANGES = Array<(int, int)>.new(0);