// Norm of a variant with unboxed cases
class VariantNorm extends TypeNorm {
	def parentNorm: VariantNorm; // null for single parent or enum

	def fieldIndexes: Array<Array<int>>;
	def origRanges: Array<(int, int)>; // null for non-single case

	def tagType: IntType;
	def tagIndex: int;
	var isEnum: bool = false;
	def isCase = parentNorm != null;
	var isSingleCase: bool = false;

	new(oldType: Type, newType: Type, tagType: IntType,
		parentNorm, origRanges, fieldIndexes, tagIndex, sub: Array<Type>) 
		super(oldType, newType, sub) {}
}

class VariantBoxBuilder {
	def rn: ReachabilityNormalizer;
	def name: string;
	private var decl: VstClass;

	var ic: IrClass;
	var rc: RaClass;

	var superIc: IrClass;
	var superRc: RaClass;

	var classType: ClassType;
	private var irBuilder: IrBuilder;
	private var constructor: IrMethod;

	new(rn, name, scType: Type, superIc, superRc) {
		var token = Token.new("<generated>", name, 0, 0);
		var superclass = if(scType != null, TypeUtil.typeRefOf(scType), null);
		decl = VstClass.new(false, token, null, null, superclass, null, null);
		decl.typeCon = V3Class_TypeCon.new(decl, rn.ra.prog.typeCache);
		classType = ClassType.!(decl.getDeclaredType());
		irBuilder = IrBuilder.new(classType, superIc);
	}

	def addParams(paramDecls: VstList<ParamDecl>) {
		var context = SsaContext.new(rn.ra.compiler, rn.ra.prog);
		var numParams = if(paramDecls != null, paramDecls.length(), 0);
		var paramTypes = Array<Type>.new(numParams);
		var params = Array<SsaParam>.new(numParams + 1);

		params[0] = SsaParam.new(0, classType);

		if (paramDecls != null) {
			for (l = paramDecls.list; l != null; l = l.tail) {
				var p = l.head;
				paramTypes[p.index - 1] = p.vtype;
				params[p.index] = SsaParam.new(p.index, p.vtype);
				irBuilder.addIrField(IrField.new(classType, p.vtype));
			}
		}

		constructor = IrMethod.new(classType, null, Function.siga(paramTypes, classType));
		constructor.setFact(Fact.M_NEW);
		irBuilder.addIrMethod(constructor);
		context.enterMethod(constructor);

		constructor.ssa = SsaGraph.new(params, classType);
		context.graph = constructor.ssa;
		var block = SsaBuilder.new(context, constructor.ssa, constructor.ssa.startBlock);
		for (i = 1; i < params.length; i++) {
			var spec = IrSpec.new(classType, [classType], irBuilder.fields[i-1]);
			block.addApply(null, V3Op.newClassInitField(spec), [params[0], params[i]]);
		}
		block.addReturn([params[0]]);
		context.printSsa("Generated");
	}
	def synthesize() {
		ic = irBuilder.build();
		rc = RaClass.new(classType, ic, superRc);

		rc.newIrType = classType;
		rn.ra.typeMap[classType] = rc;
		rn.ra.classes.put(rc);

		if (constructor != null) {
			var mc = rn.ra.makeMethod([classType], constructor, null);
			mc.raFacts |= RaFact.RM_LIVE;
			rn.ra.liveMethods.put(mc);
		}

		for (i < ic.fields.length) {
			var rf = rc.makeField(ic.fields[i], ic.fields[i].fieldType);
			ic.fields[i].raField = rf;
			rf.raFacts |= RaFact.RF_INIT | RaFact.RF_READ; // ensure fields survive during normalization
		}
	}
}

private type VariantCase(fieldTypes: Array<Array<Type>>, fieldIndexes: Array<Array<int>>) #unboxed;

class VariantSolver(nc: NormalizerConfig, rn: ReachabilityNormalizer, verbose: bool) {
	// lay out a variant's fields, which may be flattened
	def normVariant(t: Type, rc: RaClass) -> TypeNorm {
		if (rc.variantNorm != null) return rc.variantNorm; // already unboxed
		if (rc.orig.boxing == Boxing.BOXED) rn.mapSimple(t); // XXX, ugly, don't recurse through explicitly boxed types

		var prev = rc.recursive;
		match (rc.recursive) {
			ON_STACK => {
				rc.recursive = 2; // cycle detected; box
			}
			0 => {
				rc.recursive = ON_STACK;
				tryUnboxing(rc);
				if (rc.recursive == ON_STACK) rc.recursive = 1;
				if (rc.variantNorm != null) return rc.variantNorm;
			}
			// recursive or not; there was no data norm, so box
		}
		rc.raFacts |= RaFact.RC_BOXED;
		return rn.mapSimple(t);
	}
	def tryUnboxing(rc: RaClass) -> bool {
		if (rc.normFields != null) return rc.variantNorm != null; // already done

		while (rc.parent != null) rc = rc.parent;
		rn.makeNormFields(rc);
		var isEmpty = rc.normFields.length == 0, closure = rc.raFacts.RC_CLOSURE;
		var hasUnboxedCases = false;
		for (l = rc.children; l != null; l = l.tail) {
			var c = l.head;
			rn.makeNormFields(c);
			if (c.normFields.length > 0) isEmpty = false;
			if (c.orig.boxing == Boxing.UNBOXED) hasUnboxedCases = true;
			closure |= c.raFacts.RC_CLOSURE;
		}
		if (isEmpty && !closure) {
			// normalize empty variant to just its tag; i.e. become an enum
			var tagType = V3.getVariantTagType(rc.oldType);
			setVariantNormForChildren(rc, tagType, [tagType], RaFact.RC_ENUM | RaFact.RC_UNBOXED);
			return true;
		}
		if (rc.children != null) {
			if (!CLOptions.UNBOX_VARIANTS.get()) return false;
			match (rc.orig.boxing) {
				BOXED => return false;
				AUTO => if (!hasUnboxedCases) return false;
				_ => ;
			}
			return unboxUsingUnboxedNorm(rc);
		}
		match (rc.orig.boxing) {
			BOXED => return false; // program specified boxed
			AUTO => if (rc.normFields.length > nc.MaxFlatDataValues) return false; // auto unbox up to compiler limit
			UNBOXED => ; // program specified unboxed; TODO: recursion or closure should be an error
		}
		if (rc.recursive > 1 || closure) return false; // recursive or closed over
		unboxUsingSingleVariantNorm(rc);
		return true;
	}
	def unboxUsingSingleVariantNorm(rc: RaClass) {
		// Flatten a data type
		var of = rc.orig.fields;
		var origRanges = Array<(int, int)>.new(of.length);
		var fieldIndexes = Array<Array<int>>.new(of.length);
		var vecO = Vector<Type>.new();
		var vecT = Vector<Type>.new();
		// map fields of original IrClass to ranges in the original and normalized type
		for (i < of.length) {
			var origStart = vecO.length, normStart = vecT.length;
			if (i <= rc.fields.length) {
				var rf = rc.fields[i];
				if (rf != null) {
					rf.raFacts |= RaFact.RC_UNBOXED;
					if (rf.normIndex >= 0) {
						if (rf.typeNorm != null) {
							rf.typeNorm.addTo(vecT);
						} else if (rf.fieldType != null) {
							rf.typeNorm = rn.norm(rf.fieldType);
							rf.typeNorm.addTo(vecT);
						} else {
							vecT.put(rf.orig.fieldType);
						}
					}
				}
			}
			var fieldType = of[i].fieldType.substitute(V3.getTypeArgs(rc.oldType));
			rn.norm(fieldType).addTo(vecO);
			origRanges[i] = (origStart, vecO.length);
			fieldIndexes[i] = Array.new(vecT.length - normStart);
			for (j < fieldIndexes[i].length) fieldIndexes[i][j] = normStart + j;
		}

		var tagType = V3.getVariantTagType(rc.oldType);
		var ta = vecT.extract();
		rc.variantNorm = VariantNorm.new(rc.oldType, Tuple.newType(Lists.fromArray(ta)), tagType, null, origRanges, fieldIndexes, -1, ta);
		rc.variantNorm.isSingleCase = true;
		rc.raFacts |= RaFact.RC_UNBOXED;
	}
	def unboxUsingUnboxedNorm(rc: RaClass) -> bool {
		var vecT = Vector<Type>.new();
		var cases = Vector<VariantCase>.new();

		var tagType = V3.getVariantTagType(rc.oldType);
		var parentUnboxed = rc.orig.boxing == Boxing.UNBOXED;

		// superclass for all boxed cases in this partially-unboxed variant
		var boxedScName = StringBuilder.new().put1("%q$box", rc.oldType.render).toString();
		var boxedScBuilder = VariantBoxBuilder.new(rn, boxedScName, null, null, null);
		boxedScBuilder.synthesize();

		for (l = rc.children; l != null; l = l.tail) {
			var c = l.head;
			var caseUnboxed = parentUnboxed || c.orig.boxing == Boxing.UNBOXED;

			if (!caseUnboxed) {
				c.raFacts |= RaFact.RC_BOXED; // boxed case of an unboxed variant
				var boxedIndex = -1;

				var boxedClassName = StringBuilder.new().put1("%q$box", c.oldType.render).toString();
				var boxedClassBuilder = VariantBoxBuilder.new(rn, boxedClassName, boxedScBuilder.classType, boxedScBuilder.ic, boxedScBuilder.rc);
				boxedClassBuilder.addParams(ClassType.!(c.oldType).classDecl.params);
				boxedClassBuilder.synthesize();

				for (i < vecT.length) {
					var supertype = nc.UnifyRepresentations(vecT[i], boxedClassBuilder.classType);
					if (supertype != null) {
						boxedIndex = i;
						break;
					}
				}

				if (boxedIndex < 0) {
					boxedIndex = vecT.length;
					vecT.put(boxedClassBuilder.classType);
				}

				cases.put(VariantCase([[boxedClassBuilder.classType]], [[boxedIndex]]));
				continue;
			}

			c.raFacts |= RaFact.RC_UNBOXED;
			var of = c.orig.fields;
			var fieldTypes = Array<Array<Type>>.new(of.length);
			var fieldIndexes = Array<Array<int>>.new(of.length);
			var indexesUsed = HashMap<int, void>.new(int.!<int>, int.==);

			for (i < of.length) {
				var rf = c.fields[i];
				rf.raFacts |= RaFact.RC_UNBOXED;

				var nf = Vector<Type>.new();
				if (rf.typeNorm != null) rf.typeNorm.addTo(nf);
				else if (rf.fieldType != null) rn.norm(rf.fieldType).addTo(nf);
				else nf = Vectors.of1(rf.orig.fieldType);

				fieldTypes[i] = nf.extract();
				fieldIndexes[i] = Array<int>.new(fieldTypes[i].length);

				for (j < fieldTypes[i].length) {
					var assigned = -1;

					// Try to find an existing field to use
					for (k < vecT.length) {
						if (indexesUsed.has(k)) continue;

						var supertype = nc.UnifyRepresentations(fieldTypes[i][j], vecT[k]);
						if (supertype != null) {
							// TODO: Heuristic - don't always use the supertype
							vecT[k] = supertype;
							assigned = k;
							break;
						}
					}

					if (assigned < 0) {
						assigned = vecT.length;
						vecT.put(fieldTypes[i][j]);
					}
					indexesUsed[assigned] = ();
					fieldIndexes[i][j] = assigned;
				}
			}

			cases.put(VariantCase(fieldTypes, fieldIndexes));
		}

		vecT.put(tagType);
		var parentNorm = VariantNorm.new(rc.oldType, Tuple.newType(Lists.fromArray(vecT.copy())), tagType, null, null, null, vecT.length - 1, vecT.copy());
		rc.variantNorm = parentNorm; rc.raFacts |= RaFact.RC_UNBOXED;
		if (verbose) Terminal.put1("variant norm %q\n", rc.variantNorm.render);

		var caseIndex = 0;
		for (l = rc.children; l != null; l = l.tail) {
			var c = l.head;
			var vc = cases[caseIndex]; caseIndex++;
			var caseTypes = vecT.copy();

			var origRanges = Array<(int, int)>.new(vc.fieldIndexes.length);
			var curStart = 0;
			for (i < vc.fieldIndexes.length) {
				origRanges[i] = (curStart, curStart + vc.fieldIndexes[i].length);
				curStart += vc.fieldIndexes[i].length;
				for (j < vc.fieldIndexes[i].length) {
					caseTypes[vc.fieldIndexes[i][j]] = vc.fieldTypes[i][j];
				}
			}

			var caseNorm = VariantNorm.new(c.oldType, Tuple.newType(Lists.fromArray(caseTypes)), tagType, parentNorm, origRanges, vc.fieldIndexes, vecT.length - 1, caseTypes);
			c.variantNorm = caseNorm;
			if (verbose) Terminal.put1("-- case norm %q\n", caseNorm.render);
		}
		
		return true;
	}
	def setVariantNormForChildren(rc: RaClass, tagType: IntType, sub: Array<Type>, facts: RaFact.set) {
		rc.variantNorm = VariantNorm.new(rc.oldType, tagType, tagType, null, Array<(int, int)>.new(0), Array<Array<int>>.new(0), 0, [tagType]);
		rc.variantNorm.isEnum = true;

		rc.raFacts |= facts;
		for (l = rc.children; l != null; l = l.tail) {
			setVariantNormForChildren(l.head, tagType, sub, facts);
		}
	}
}
def ON_STACK = -1;
def NO_RANGES = Array<(int, int)>.new(0);