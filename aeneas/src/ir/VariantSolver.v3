// Norm of a variant with unboxed cases
class VariantNorm extends TypeNorm {
	def parentNorm: VariantNorm; // null for single parent or enum
	def caseFields: Array<VariantField>;
	def tagField: VariantField;
	var isEnum: bool = false;

	new(oldType: Type, newType: Type,
		parentNorm, caseFields, tagField, sub: Array<Type>) 
		super(oldType, newType, sub) {}
	
	def isSingleCase() -> bool {
		return tagField == null;
	}
	def isEmpty() -> bool {
		return caseFields.length == 0;
	}
	def tagIndex() -> int {
		// TODO: Replace when tag becomes potentially packed
		return tagField.indexes[0];
	}
	def tagType() -> IntType {
		// TODO: Replace when tag becomes potentially packed
		return IntType.!(tagField.types[0]);
	}
	def render(buf: StringBuilder) -> StringBuilder {
		buf.put3("%q ## %q |%d|", oldType.render, newType.render, size);
		buf.puts(" [");
		for (i < sub.length) {
			if (i > 0) buf.csp();
			sub[i].render(buf);
		}
		buf.puts("] {");
		for (i < caseFields.length) {
			if (i > 0) buf.csp();
			caseFields[i].render(buf);
		}
		buf.puts("}");
		return buf;
	}
}

// Metadata for each case's field
class VariantField(types: Array<Type>, indexes: Array<int>, origRange: (int, int)) {
	def render(buf: StringBuilder) -> StringBuilder {
		buf.put2("(%d..%d) -> ", origRange.0, origRange.1);
		buf.putc('(');
		for (i < indexes.length) {
			if (i > 0) buf.csp();
			buf.put1("#%d", indexes[i]);
		}
		buf.puts("): [");
		for (i < types.length) {
			if (i > 0) buf.csp();
			types[i].render(buf);
		}
		buf.puts("]");
		return buf;
	}
}

// Defines mapping between location of bits in packed scalar
class Packing {
	def scalarType: IntType;
	def origRanges: Array<(int, int)>;
	def newRanges: Array<(int, int)>;
}

class VariantBoxBuilder {
	def rn: ReachabilityNormalizer;
	def name: string;
	private var decl: VstClass;

	var ic: IrClass;
	var rc: RaClass;

	var superIc: IrClass;
	var superRc: RaClass;

	var classType: ClassType;
	private var irBuilder: IrBuilder;
	private var constructor: IrMethod;

	new(rn, name, scType: Type, superIc, superRc) {
		var token = Token.new("<generated>", name, 0, 0);
		var superclass = if(scType != null, TypeUtil.typeRefOf(scType), null);
		decl = VstClass.new(false, token, null, null, superclass, null, null);
		decl.typeCon = V3Class_TypeCon.new(decl, rn.ra.prog.typeCache);
		classType = ClassType.!(decl.getDeclaredType());
		irBuilder = IrBuilder.new(classType, superIc);
	}

	def addParams(paramDecls: VstList<ParamDecl>) {
		var context = SsaContext.new(rn.ra.compiler, rn.ra.prog);
		var numParams = if(paramDecls != null, paramDecls.length(), 0);
		var paramTypes = Array<Type>.new(numParams);
		var params = Array<SsaParam>.new(numParams + 1);

		params[0] = SsaParam.new(0, classType);

		if (paramDecls != null) {
			for (l = paramDecls.list; l != null; l = l.tail) {
				var p = l.head;
				paramTypes[p.index - 1] = p.vtype;
				params[p.index] = SsaParam.new(p.index, p.vtype);
				irBuilder.addIrField(IrField.new(classType, p.vtype));
			}
		}

		constructor = IrMethod.new(classType, null, Function.siga(paramTypes, classType));
		constructor.setFact(Fact.M_NEW);
		irBuilder.addIrMethod(constructor);
		context.enterMethod(constructor);

		constructor.ssa = SsaGraph.new(params, classType);
		context.graph = constructor.ssa;
		var block = SsaBuilder.new(context, constructor.ssa, constructor.ssa.startBlock);
		for (i = 1; i < params.length; i++) {
			var spec = IrSpec.new(classType, [classType], irBuilder.fields[i-1]);
			block.addApply(null, V3Op.newClassInitField(spec), [params[0], params[i]]);
		}
		block.addReturn([params[0]]);
		context.printSsa("Generated");
	}
	def synthesize() {
		ic = irBuilder.build();
		rc = RaClass.new(classType, ic, superRc);

		rc.newIrType = classType;
		rn.ra.typeMap[classType] = rc;
		rn.ra.classes.put(rc);

		if (constructor != null) {
			var mc = rn.ra.makeMethod([classType], constructor, null);
			mc.raFacts |= RaFact.RM_LIVE;
			rn.ra.liveMethods.put(mc);
		}

		for (i < ic.fields.length) {
			var rf = rc.makeField(ic.fields[i], ic.fields[i].fieldType);
			ic.fields[i].raField = rf;
			rf.raFacts |= RaFact.RF_INIT | RaFact.RF_READ; // ensure fields survive during normalization
		}
	}
}

private type VariantCase(fields: Array<VariantField>) #unboxed;

class VariantSolver(nc: NormalizerConfig, rn: ReachabilityNormalizer, verbose: bool) {
	// lay out a variant's fields, which may be flattened
	def normVariant(t: Type, rc: RaClass) -> TypeNorm {
		if (rc.variantNorm != null) return rc.variantNorm; // already unboxed
		if (rc.orig.boxing == Boxing.BOXED) rn.mapSimple(t); // XXX, ugly, don't recurse through explicitly boxed types

		var prev = rc.recursive;
		match (rc.recursive) {
			ON_STACK => {
				rc.recursive = 2; // cycle detected; box
			}
			0 => {
				rc.recursive = ON_STACK;
				tryUnboxing(rc);
				if (rc.recursive == ON_STACK) rc.recursive = 1;
				if (rc.variantNorm != null) return rc.variantNorm;
			}
			// recursive or not; there was no data norm, so box
		}
		rc.raFacts |= RaFact.RC_BOXED;
		return rn.mapSimple(t);
	}
	def tryUnboxing(rc: RaClass) -> bool {
		if (rc.normFields != null) return rc.variantNorm != null; // already done

		while (rc.parent != null) rc = rc.parent;
		rn.makeNormFields(rc);
		var isEmpty = rc.normFields.length == 0, closure = rc.raFacts.RC_CLOSURE;
		var hasUnboxedCases = false;
		for (l = rc.children; l != null; l = l.tail) {
			var c = l.head;
			rn.makeNormFields(c);
			if (c.normFields.length > 0) isEmpty = false;
			if (c.orig.boxing == Boxing.UNBOXED) hasUnboxedCases = true;
			closure |= c.raFacts.RC_CLOSURE;
		}
		if (isEmpty && !closure) {
			// normalize empty variant to just its tag; i.e. become an enum
			var tagType = V3.getVariantTagType(rc.oldType);
			var tagField = VariantField.new([tagType], [0], (0, 0));
			setVariantNormForChildren(rc, tagField, [tagType], RaFact.RC_ENUM | RaFact.RC_UNBOXED);
			return true;
		}
		if (rc.children != null) {
			if (!CLOptions.UNBOX_VARIANTS.get()) return false;
			match (rc.orig.boxing) {
				BOXED => return false;
				AUTO => if (!hasUnboxedCases) return false;
				_ => ;
			}
			return unboxUsingUnboxedNorm(rc);
		}
		match (rc.orig.boxing) {
			BOXED => return false; // program specified boxed
			AUTO => if (rc.normFields.length > nc.MaxFlatDataValues) return false; // auto unbox up to compiler limit
			UNBOXED => ; // program specified unboxed; TODO: recursion or closure should be an error
		}
		if (rc.recursive > 1 || closure) return false; // recursive or closed over
		unboxUsingSingleVariantNorm(rc);
		return true;
	}
	def unboxUsingSingleVariantNorm(rc: RaClass) {
		// Flatten a data type
		var of = rc.orig.fields;
		var caseFields = Array<VariantField>.new(of.length);
		var vecO = Vector<Type>.new();
		var vecT = Vector<Type>.new();
		// map fields of original IrClass to ranges in the original and normalized type
		for (i < of.length) {
			var normStart = vecT.length, origStart = vecO.length;
			if (i <= rc.fields.length) {
				var rf = rc.fields[i];
				if (rf != null) {
					rf.raFacts |= RaFact.RC_UNBOXED;
					if (rf.normIndex >= 0) {
						if (rf.typeNorm != null) {
							rf.typeNorm.addTo(vecT);
						} else if (rf.fieldType != null) {
							rf.typeNorm = rn.norm(rf.fieldType);
							rf.typeNorm.addTo(vecT);
						} else {
							vecT.put(rf.orig.fieldType);
						}
					}
				}
			}
			var fieldType = of[i].fieldType.substitute(V3.getTypeArgs(rc.oldType));
			rn.norm(fieldType).addTo(vecO);
			var indexes = Array<int>.new(vecT.length - normStart);
			for (j < indexes.length) indexes[j] = normStart + j;
			caseFields[i] = VariantField.new(Arrays.range(vecT.array, normStart, vecT.length), indexes, (origStart, vecO.length));
		}

		var ta = vecT.extract();
		rc.variantNorm = VariantNorm.new(rc.oldType, Tuple.newType(Lists.fromArray(ta)), null, caseFields, null, ta);
		rc.raFacts |= RaFact.RC_UNBOXED;

		if (verbose) Terminal.put1("variant norm %q\n", rc.variantNorm.render);
	}
	def unboxUsingUnboxedNorm(rc: RaClass) -> bool {
		var vecT = Vector<Type>.new();
		var cases = Vector<VariantCase>.new();

		var tagType = V3.getVariantTagType(rc.oldType);
		var parentUnboxed = rc.orig.boxing == Boxing.UNBOXED;

		// superclass for all boxed cases in this partially-unboxed variant
		var boxedScName = StringBuilder.new().put1("%q$box", rc.oldType.render).toString();
		var boxedScBuilder = VariantBoxBuilder.new(rn, boxedScName, null, null, null);
		boxedScBuilder.synthesize();

		for (l = rc.children; l != null; l = l.tail) {
			var c = l.head;
			var caseUnboxed = parentUnboxed || c.orig.boxing == Boxing.UNBOXED;

			if (!caseUnboxed) {
				c.raFacts |= RaFact.RC_BOXED; // boxed case of an unboxed variant
				var boxedIndex = -1;

				var boxedClassName = StringBuilder.new().put1("%q$box", c.oldType.render).toString();
				var boxedClassBuilder = VariantBoxBuilder.new(rn, boxedClassName, boxedScBuilder.classType, boxedScBuilder.ic, boxedScBuilder.rc);
				boxedClassBuilder.addParams(ClassType.!(c.oldType).classDecl.params);
				boxedClassBuilder.synthesize();

				for (i < vecT.length) {
					var supertype = nc.UnifyRepresentations(vecT[i], boxedClassBuilder.classType);
					if (supertype != null) {
						boxedIndex = i;
						break;
					}
				}
				if (boxedIndex < 0) {
					boxedIndex = vecT.length;
					vecT.put(boxedClassBuilder.classType);
				}
				cases.put(VariantCase([VariantField.new([boxedClassBuilder.classType], [boxedIndex], (0, 0))]));
				continue;
			}

			c.raFacts |= RaFact.RC_UNBOXED;
			var of = c.orig.fields;
			var caseFields = Array<VariantField>.new(of.length);
			var indexesUsed = HashMap<int, void>.new(int.!<int>, int.==);
			var vecO = Vector<Type>.new();

			for (i < of.length) {
				var rf = c.fields[i];
				rf.raFacts |= RaFact.RC_UNBOXED;

				var nf = Vector<Type>.new();
				if (rf.typeNorm != null) rf.typeNorm.addTo(nf);
				else if (rf.fieldType != null) rn.norm(rf.fieldType).addTo(nf);
				else nf = Vectors.of1(rf.orig.fieldType);

				var fieldTypes = nf.extract();
				var indexes = Array<int>.new(fieldTypes.length);

				for (j < fieldTypes.length) {
					var assigned = -1;

					// Try to find an existing field to use
					for (k < vecT.length) {
						if (indexesUsed.has(k)) continue;

						var supertype = nc.UnifyRepresentations(fieldTypes[j], vecT[k]);
						if (supertype != null) {
							// TODO: Heuristic - don't always use the supertype
							vecT[k] = supertype;
							assigned = k;
							break;
						}
					}

					if (assigned < 0) {
						assigned = vecT.length;
						vecT.put(fieldTypes[j]);
					}
					indexesUsed[assigned] = ();
					indexes[j] = assigned;
				}
				var origStart = vecO.length;
				var fieldType = of[i].fieldType.substitute(V3.getTypeArgs(rc.oldType));
				rn.norm(fieldType).addTo(vecO);
				caseFields[i] = VariantField.new(fieldTypes, indexes, (origStart, vecO.length));
			}
			cases.put(VariantCase(caseFields));
		}

		if (rc.recursive > 1) return false;

		vecT.put(tagType);
		var tagField = VariantField.new([tagType], [vecT.length - 1], (0, 0));
		var parentNorm = VariantNorm.new(rc.oldType, Tuple.newType(Lists.fromArray(vecT.copy())), null, NO_FIELDS, tagField, vecT.copy());
		rc.variantNorm = parentNorm; rc.raFacts |= RaFact.RC_UNBOXED;
		if (verbose) Terminal.put1("variant norm %q\n", rc.variantNorm.render);

		var caseIndex = 0;
		for (l = rc.children; l != null; l = l.tail) {
			var c = l.head;
			var vc = cases[caseIndex]; caseIndex++;
			var caseTypes = vecT.copy();

			for (field in vc.fields) {
				for (j < field.indexes.length) {
					caseTypes[field.indexes[j]] = field.types[j];
				}
			}

			var caseNorm = VariantNorm.new(c.oldType, Tuple.newType(Lists.fromArray(caseTypes)), parentNorm, vc.fields, tagField, caseTypes);
			c.variantNorm = caseNorm;
			if (verbose) Terminal.put1("-- case norm %q\n", caseNorm.render);
		}
		return true;
	}
	def setVariantNormForChildren(rc: RaClass, tagField: VariantField, sub: Array<Type>, facts: RaFact.set) {
		var tagType = tagField.types[0];
		rc.variantNorm = VariantNorm.new(rc.oldType, tagType, null, NO_FIELDS, tagField, [tagType]);
		rc.variantNorm.isEnum = true;

		rc.raFacts |= facts;
		for (l = rc.children; l != null; l = l.tail) {
			setVariantNormForChildren(l.head, tagField, sub, facts);
		}
	}
}
def ON_STACK = -1;
def NO_FIELDS = Array<VariantField>.new(0);
def NO_RANGES = Array<(int, int)>.new(0);