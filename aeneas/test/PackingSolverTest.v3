// Copyright 2024 Virgil authors. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

def T = UnitTests.registerT("packing:", _, PackingSolverTester.new, _);
def X = [
	T("nonrefs", test_nonrefs),
	T("nonrefs_64", test_nonrefs_64),
	T("nonrefs_assigned", test_nonrefs_assigned),
	T("refs", test_refs),
	T("refs_64", test_refs_64)
];
def VERBOSE = false;

class PackingSolverTester(t: Tester) {
	var solver: PackingSolver;
	def useSolver(s: PackingSolver) { solver = s; }

	private def trySolve(cases: Array<Array<PackingField>>, assignments: Array<(CaseField, Interval)>) -> HashMap<CaseField, Interval> {
		solver.reset();
		var solution = solver.solveScalar(cases, assignments);
		if (VERBOSE) printSolution(cases, solution);
		return solution;
	}
	def printSolution(cases: Array<Array<PackingField>>, solution: HashMap<CaseField, Interval>) {
		if (solution == null) {
			Terminal.put("no solution found\n");
			return;
		}

		for (i < cases.length) {
			Terminal.put1("case #%d:\n", i);
			for (j < cases[i].length) Terminal.put2("  field #%d: %q\n", j, solution[CaseField(i, j)].render);
		}
	}

	def renderProblem(sb: StringBuilder, cases: Array<Array<PackingField>>, assignments: Array<(CaseField, Interval)>) -> StringBuilder {
		var h = HashMap<CaseField, Interval>.new(CaseField.hash, CaseField.==);
		for (a in assignments) h[a.0] = a.1;

		for (i < cases.length) {
			if (i > 0) sb.csp();
			sb.put1("#%d=[", i);
			for (j < cases[i].length) {
				if (j > 0) sb.csp();
				match (cases[i][j]) {
					Nonref(s) => sb.put1("%d", s);
					Ref => sb.puts("ref");
				}
				var cf = CaseField(i, j);
				if (h.has(cf)) sb.put1("@%q", h[cf].render);
			}
			sb.puts("]");
		}
		return sb;
	}

	def assert_unsolvable(cases: Array<Array<PackingField>>, assignments: Array<(CaseField, Interval)>) {
		var solution = trySolve(cases, assignments);
		var rp = renderProblem(_, cases, assignments);
		t.assert(solution == null, Strings.format1("%q: expected no solution, found solution", rp));
	}
	def assert_solvable(cases: Array<Array<PackingField>>, assignments: Array<(CaseField, Interval)>) {
		var solution = trySolve(cases, assignments);
		var rp = renderProblem(_, cases, assignments);
		t.assert(solution != null, Strings.format1("%q: expected solution, no solution found", rp));

		verifyValidity(cases, assignments, solution);
	}
	def assert_unsolvable0(cases: Array<Array<PackingField>>) { return assert_unsolvable(cases, []); }
	def assert_solvable0(cases: Array<Array<PackingField>>) { return assert_solvable(cases, []); }

	private def verifyValidity(cases: Array<Array<PackingField>>, assignments: Array<(CaseField, Interval)>, solution: HashMap<CaseField, Interval>) {
		var rp = renderProblem(_, cases, assignments);
		for (a in assignments) {
			if (solution[a.0] != a.1) t.fail(Strings.format1("%q: specified assignment not obeyed", rp));
		}
		for (i < cases.length) {
			for (j < cases[i].length) {
				var cf = CaseField(i, j);
				if (!solution.has(cf)) t.fail(Strings.format1("%q: missing assignment", rp));
				var s = solution[cf];

				match (cases[i][j]) {
					Ref => ;
					Nonref(size) => if (s.e - s.s != size) t.fail(Strings.format1("%q: wrong assignment size", rp));
				}
			}
		}

		for (i < cases.length) {
			for (j < cases[i].length) {
				for (k < j) {
					var sj = solution[CaseField(i, j)];
					var sk = solution[CaseField(i, k)];
					if (sj.s < sk.e && sk.s < sj.e) t.fail(Strings.format3("%q: overlapping fields %q and %q", rp, sj.render, sk.render));
				}
			}
		}

		// TODO: verify cases are distinguishable
	}
}
def NR = PackingField.Nonref;
def R = PackingField.Ref;
def CF = CaseField;
def I = Interval;

def test_nonrefs(t: PackingSolverTester) {
	t.useSolver(PackingSolver.new(32, PackingPatterns.X86));

	t.assert_solvable0([[NR(32)]]);
	t.assert_solvable0([[NR(16), NR(16)]]);
	t.assert_solvable0([[NR(16), NR(15)], [NR(16), NR(12)]]);
	t.assert_solvable0([[NR(16), NR(15)], [NR(16), NR(15)]]);
	t.assert_solvable0([[NR(15), NR(16)], [NR(16), NR(15)]]);
	t.assert_solvable0([[NR(15), NR(15)], [NR(7), NR(15), NR(8)], [NR(15), NR(15)]]);

	t.assert_unsolvable0([[NR(16), NR(16)], [NR(16), NR(12)]]);
	t.assert_unsolvable0([[NR(16), NR(8), NR(8)], [NR(16), NR(12)]]);
}

def test_nonrefs_assigned(t: PackingSolverTester) {
	t.useSolver(PackingSolver.new(32, PackingPatterns.X86));

	t.assert_solvable(
		[[NR(16), NR(15)], [NR(16), NR(12)]],
		[(CF(0, 0), I(16, 32))]
	);

	// should fail, because we don't support non-contiguous intervals
	t.assert_unsolvable(
		[[NR(16), NR(15)], [NR(16), NR(12)]],
		[(CF(0, 0), I(12, 27))]
	);
	t.assert_solvable(
		[[NR(10), NR(15)], [NR(16), NR(12)]],
		[(CF(0, 1), I(12, 27))]
	);
}

def test_nonrefs_64(t: PackingSolverTester) {
	t.useSolver(PackingSolver.new(64, PackingPatterns.X86_64));

	t.assert_solvable0([[NR(64)]]);
	t.assert_solvable0([[NR(32), NR(32)]]);
	t.assert_solvable0([[NR(16), NR(15)], [NR(16), NR(12)]]);
	t.assert_solvable0([[NR(16), NR(15)], [NR(16), NR(15)]]);
	t.assert_solvable0([[NR(15), NR(16)], [NR(16), NR(15)]]);
	t.assert_solvable0([[NR(15), NR(15)], [NR(7), NR(15), NR(8)], [NR(15), NR(15)]]);
	t.assert_solvable0([[NR(16), NR(16)], [NR(16), NR(12)]]);
	t.assert_solvable0([[NR(16), NR(8), NR(8)], [NR(16), NR(12)]]);
}

def test_refs(t: PackingSolverTester) {
	t.useSolver(PackingSolver.new(32, PackingPatterns.X86));

	t.assert_solvable0([[R]]);
	t.assert_solvable0([[R], [R]]);
	t.assert_solvable0([[R], [R], [R]]);
	t.assert_solvable0([[R], [R], [R], [R]]);
	t.assert_solvable0([[R], [NR(16)]]);
	t.assert_solvable0([[R], [NR(31)]]);
	t.assert_solvable0([[R], [NR(16)], [NR(16)]]);
	t.assert_solvable0([[R, NR(2)]]);
	t.assert_solvable0([[R, NR(1)], [R, NR(1)]]);
	t.assert_solvable0([[R], [R], [NR(30)], [NR(30)]]);
	t.assert_solvable0([[R], []]);

	t.assert_unsolvable0([[R, R]]);
	t.assert_unsolvable0([[R], [NR(32)]]);
}

def test_refs_64(t: PackingSolverTester) {
	t.useSolver(PackingSolver.new(64, PackingPatterns.X86_64));

	t.assert_solvable0([[R]]);
	t.assert_solvable0([[R], [R]]);
	t.assert_solvable0([[R], [R], [R]]);
	t.assert_solvable0([[R], [R], [R], [R]]);
	t.assert_solvable0([[R], [NR(32)]]);
	t.assert_solvable0([[R], [NR(63)]]);
	t.assert_solvable0([[R], [NR(32)], [NR(32)]]);
	t.assert_solvable0([[R, NR(3)]]);
	t.assert_solvable0([[R, NR(1)], [R, NR(1)]]);

	t.assert_unsolvable0([[R, R]]);
	t.assert_unsolvable0([[R], [NR(64)]]);
}
