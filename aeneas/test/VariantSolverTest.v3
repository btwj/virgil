// Copyright 2024 Virgil authors. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

def T = UnitTests.registerT("packing:", _, VariantSolverTester.new, _);
def X = [
    T("simple", test_simple)
];
def VERBOSE = false;

def makeNormConfig(usedScalars: Scalar.set, getScalar: Type -> Scalar.set, getBitWidth: Type -> byte) -> NormalizerConfig {
    var nc = NormalizerConfig.new();

    nc.UsedScalars = usedScalars;
    if (getScalar != null) nc.GetScalar = getScalar;
    if (getBitWidth != null) nc.GetBitWidth = getBitWidth;

    return nc;
}

class VariantSolverTester(t: Tester) {
    var solver: VariantSolver;
	def useSolver(s: VariantSolver) { solver = s; }

	def assert_solvable(p: VariantProblem) -> VariantSolution {
		var s = trySolve(p);
		if (s == null) t.fail(Strings.format1("%q: expected solution, no solution found", p.render));
		else verifyValidity(p, s);
		return s;
	}
	def assert_solvable_with_size(p: VariantProblem, size: byte) -> VariantSolution {
		var s = assert_solvable(p);
		if (s == null) return s;
		if (s.size() > size)  t.fail(Strings.format3("%q: expected solution with size <= %d, found solution %q", p.render, size, s.render));
		return s;
	}
	def assert_unsolvable(p: VariantProblem) {
		var s = trySolve(p);
		if (s != null) t.fail(Strings.format2("%q: expected no solution, found solution %q", p.render, s.render));
	}
	def assert_unsolvable_with_size(p: VariantProblem, size: byte) {
		var s = trySolve(p);
		if (s != null && s.size() <= size) t.fail(Strings.format3("%q: expected unsolvable with size <= %d, found solution %q", p.render, size, s.render));;
	}
	private def trySolve(problem: VariantProblem) -> VariantSolution {
		var solution = solver.solve(problem);
		if (VERBOSE) Terminal.put2("%q => %q\n", problem.render, printSolution(_, solution));
		return solution;
	}
	private def printSolution(sb: StringBuilder, solution: VariantSolution) -> StringBuilder {
		if (solution == null) return sb.puts("no solution found");
		else return solution.render(sb);
	}
	private def verifyValidity(problem: VariantProblem, solution: VariantSolution) {
	}
}

def test_simple(t: VariantSolverTester) {
    var nc = makeNormConfig(Scalar.B32, null, null), p: VariantProblem;
    t.useSolver(VariantSolver.new(nc));

    p = VariantProblem.new([], [], false);
    t.assert_solvable(p);

    p = VariantProblem.new([[Int.TYPE]], null, false);
    t.assert_solvable_with_size(p, 1);

    p = VariantProblem.new([[Int.TYPE], [Int.TYPE]], null, false);
    t.assert_unsolvable_with_size(p, 1);
    t.assert_solvable_with_size(p, 2);
}
