//@execute =1

def agrow<T>(array: Array<T>, size: int) -> Array<T> {
    if (size > array.length) {
        var n = Array<T>.new(size), max = array.length;
        for (i < max) n[i] = array[i];
        return n;
    }
    return array;
}

// An efficient data structure for a matrix of boolean values.
class BitMatrix(var numrows: int, var numcols: int) {
	private var width: int = (numcols + 31) >>> 5;      // width (in integers) of each row
	private var bits = Array<int>.new(numrows * width); // array that stores the data
	// get the value of the bit at {row, col}
	def [row: int, col: int] -> bool {
		var i = row * width + (col >>> 5), mask = 1 << u5.view(col);
		return (bits[i] & mask) != 0;
	}
	// set the bit at {row, col}
	def [row: int, col: int] = val: bool {
		var i = row * width + (col >>> 5), mask = 1 << u5.view(col);
		var prev = bits[i];
		if (val) {
			// set the bit if not already set.
			if ((prev & mask) == 0) bits[i] = prev | mask;
		} else {
			// clear the bit if it is set.
			if ((prev & mask) != 0) bits[i] = prev & ~mask;
		}
	}
	// set the bit at the specified position, returning its previous value
	def set(row: int, col: int) -> bool {
		var i = row * width + (col >> 5), mask = 1 << u5.view(col);
		var val = bits[i];
		if ((val & mask) == 0) {
			bits[i] = val | mask;
			return false;
		}
		return true;
	}
	// OR rows {a} and {b} together, storing the result in row {a}
	def or(a: int, b: int) {
		var array = bits;
		var da = a * width, db = b * width;
		for (i < width) array[da + i] = array[da + i] | array[db + i];
	}
	// extract a range of rows from {minRow} inclusive to {maxRow} exclusive into a new BitMatrix
	def range(minRow: int, maxRow: int) -> BitMatrix {
		var numrows = maxRow - minRow;
		var result = BitMatrix.new(numrows, numcols);
		var start = minRow * width, end = maxRow * width;
		var sbits = this.bits, rbits = result.bits;
		for (i = start; i < end; i++) rbits[i - start] = sbits[i];
		return result;
	}
	def row(index: int) -> BitMatrixRow {
		var a: BitMatrixRow;
		if (index >= numrows) return a;
		return BitMatrixRow(this, index);
	}
	def rowInts(index: int) -> Range<int> {
		if (index >= numrows) return null;
		return bits[(index * width) ..+ width];
	}
	def last() -> BitMatrixRow {
		var a: BitMatrixRow;
		if (numrows <= 0) return a;
		return BitMatrixRow(this, numrows - 1);
	}
}

// A wrapper around a row that simplifies indexing math of rows.
type BitMatrixRow(matrix: BitMatrix, index: int) #unboxed {
	// OR this row with {that} row from the same matrix.
	def or(that: BitMatrixRow) {
		matrix.or(index, that.index);
	}
	// Get the next row {delta} rows down.
	def plus(delta: int) -> BitMatrixRow {
		return matrix.row(index + delta);
	}
	// Get column {col} in this row.
	def [col: int] -> bool {
		return matrix[index, col];
	}
	// Set column {col} in this row to {val}.
	def [col: int] = val: bool {
		matrix[index, col] = val;
	}
}

var arr: Array<int> = [];
def assert(b: bool) {
    if (!b) var x = arr[2];
}

def main() -> int {
	var b = BitMatrix.new(10, 62);
	for (i < 31) {
		for (j < 10)
			if (j % 3 == 0) b[j, i*2] = true;
	}
	var x = b.rowInts(2);
	var y = b.rowInts(5);
    return 1;
}